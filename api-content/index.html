{"posts":[{"title":"Kuberneteså­¦ä¹ ç¬”è®° - Volume Manager","content":" æ‰€æœ‰çš„ç›¸å…³ä»£ç ï¼Œéƒ½åŸºäºkubernetes v19.3 1. è¿è¡ŒåŸç† kubeletå¯åŠ¨æ—¶ä¼šè°ƒç”¨volumeManangerçš„ Run æ–¹æ³•å¯åŠ¨å·ç®¡ç†å™¨ã€‚ å®ƒè´Ÿè´£åœ¨å½“å‰èŠ‚ç‚¹çš„ Pod å’Œ Volume å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œå¯¹ Volume è¿›è¡ŒæŒ‚è½½å’Œå¸è½½ç­‰æ“ä½œã€‚ func (vm *volumeManager) Run(sourcesReady config.SourcesReady, stopCh &lt;-chan struct{}) { defer runtime.HandleCrash() go vm.desiredStateOfWorldPopulator.Run(sourcesReady, stopCh) go vm.reconciler.Run(stopCh) metrics.Register(vm.actualStateOfWorld, vm.desiredStateOfWorld, vm.volumePluginMgr) if vm.kubeClient != nil { vm.volumePluginMgr.Run(stopCh) } &lt;-stopCh klog.Infof(&quot;Shutting down Kubelet Volume Manager&quot;) } ä¸»è¦åšä¸¤ä»¶äº‹æƒ… desiredStateOfWorldPopulatorä¸»è¦è´Ÿè´£ä» API server ä¸­è·å– Pod çš„ä¿¡æ¯ï¼Œå°†ä»–ä»¬æ›´æ–°åˆ°æœ¬åœ°çš„ä¸€ä¸ªDesiredStateOfWorldçš„æ•°æ®ç»“æ„ä¸­ã€‚ reconciler è´Ÿè´£è°ƒè°ï¼Œä¹Ÿå°±æ˜¯æ ¹æ®DesiredStateOfWorld çš„çŠ¶æ€å˜æ›´ï¼Œæ›´æ–°å®é™…çš„æŒ‚è½½ä¿¡æ¯ã€‚ åœ¨ Pod çš„å¯åŠ¨è¿‡ç¨‹ä¸­ï¼Œå¦‚æœéœ€è¦æŒ‚è½½å·ï¼Œåˆ™é¦–å…ˆç­‰å¾…å·æŒ‚è½½å®Œæˆä¹‹åï¼Œæ‰å¯ä»¥ç»§ç»­å‘ä¸‹è¿›è¡Œã€‚ 2. DesiredStateOfWorld æ‰§è¡Œä¸€ä¸ªå¤§å¾ªç¯ï¼Œ åšçš„äº‹æƒ…å¤§è‡´ä¹Ÿæœ‰ä¸¤ä¸ª findAndAddNewPods findAndRemoveDeletedPods é€šè¿‡ä»¥ä¸Šä¸¤ä¸ªæ–¹æ³•ï¼Œåˆ†åˆ«è·å–èŠ‚ç‚¹ä¸­è¢«æ·»åŠ çš„æ–° Pod æˆ–è€…å·²ç»åˆ é™¤çš„è€çš„ Podï¼Œè·å–åˆ° Pod ä¹‹åä¼šæ ¹æ®å½“å‰çš„çŠ¶æ€ä¿®æ”¹æœŸæœ›çŠ¶æ€ findAndAddNewPods //kubelet/volumemanager/populator/desired_state_of_world_populator.go func (dswp *desiredStateOfWorldPopulator) findAndAddNewPods() { // Map unique pod name to outer volume name to MountedVolume. mountedVolumesForPod := make(map[volumetypes.UniquePodName]map[string]cache.MountedVolume) ...... processedVolumesForFSResize := sets.NewString() //è·å–æ‰€æœ‰çš„ pod æ•°æ® for _, pod := range dswp.podManager.GetPods() { //å¦‚æœæ˜¯ç»ˆæ­¢çš„ podï¼Œä¸ç”¨æŒ‚è½½å· if dswp.isPodTerminated(pod) { continue } //å¤„ç†ç‰¹å®šçš„ pod çš„å·ä¿¡æ¯ï¼ŒæŠŠä»–ä»¬æ”¾åˆ°ä¸€ä¸ªdesired stateçš„æ•°æ®ç»“æ„é‡Œå» dswp.processPodVolumes(pod, mountedVolumesForPod, processedVolumesForFSResize) } } func (dswp *desiredStateOfWorldPopulator) processPodVolumes( pod *v1.Pod, mountedVolumesForPod map[volumetypes.UniquePodName]map[string]cache.MountedVolume, processedVolumesForFSResize sets.String) { if pod == nil { return } //è·å– pod çš„UID uniquePodName := util.GetUniquePodName(pod) //åœ¨å½“å‰processedPodsä¸­ç¼“å­˜æœ‰è¿™ä¸ª pod çš„ä¿¡æ¯ï¼Œå°±ä¸å¤„ç†äº† if dswp.podPreviouslyProcessed(uniquePodName) { return } allVolumesAdded := true mounts, devices := util.GetPodVolumeNames(pod) expandInUsePV := utilfeature.DefaultFeatureGate.Enabled(features.ExpandInUsePersistentVolumes) // ä» Pod çš„å®šä¹‰ä¸­æ‹¿åˆ°æ‰€æœ‰çš„å¾…ç»‘å®šçš„å·ä¿¡æ¯ for _, podVolume := range pod.Spec.Volumes { if !mounts.Has(podVolume.Name) &amp;&amp; !devices.Has(podVolume.Name) { continue } //åˆ›å»ºå·ä¿¡æ¯, åç»­å†å…·ä½“åˆ†æè¿™ä¸ªä»£ç  pvc, volumeSpec, volumeGidValue, err := dswp.createVolumeSpec(podVolume, pod, mounts, devices) if err != nil { dswp.desiredStateOfWorld.AddErrorToPod(uniquePodName, err.Error()) allVolumesAdded = false continue } // æŠŠå·ä¿¡æ¯æ·»åŠ åˆ°æ•°æ®ç»“æ„ä¸­ _, err = dswp.desiredStateOfWorld.AddPodToVolume( uniquePodName, pod, volumeSpec, podVolume.Name, volumeGidValue) if err != nil { dswp.desiredStateOfWorld.AddErrorToPod(uniquePodName, err.Error()) allVolumesAdded = false } else { } if expandInUsePV { dswp.checkVolumeFSResize(pod, podVolume, pvc, volumeSpec, uniquePodName, mountedVolumesForPod, processedVolumesForFSResize) } } //å¦‚æœæ‰€æœ‰çš„å·éƒ½å¤„ç†å®Œæ¯•äº†ï¼Œæ ‡è®°å¤„ç†å®Œæˆ if allVolumesAdded { dswp.markPodProcessed(uniquePodName) // New pod has been synced. Re-mount all volumes that need it // (e.g. DownwardAPI) dswp.actualStateOfWorld.MarkRemountRequired(uniquePodName) // Remove any stored errors for the pod, everything went well in this processPodVolumes dswp.desiredStateOfWorld.PopPodErrors(uniquePodName) } else if dswp.podHasBeenSeenOnce(uniquePodName) { // For the Pod which has been processed at least once, even though some volumes // may not have been reprocessed successfully this round, we still mark it as processed to avoid // processing it at a very high frequency. The pod will be reprocessed when volume manager calls // ReprocessPod() which is triggered by SyncPod. dswp.markPodProcessed(uniquePodName) } } åšçš„ä¸»è¦çš„äº‹æƒ…å°±æ˜¯å°†èŠ‚ç‚¹åŠ å…¥çš„æ–° Pod æ·»åŠ åˆ°DesiredStateOfWorld ä¸­ã€‚ findAndRemoveDeletedPods func (dswp *desiredStateOfWorldPopulator) findAndRemoveDeletedPods() { var runningPods []*kubecontainer.Pod runningPodsFetched := false for _, volumeToMount := range dswp.desiredStateOfWorld.GetVolumesToMount() { pod, podExists := dswp.podManager.GetPodByUID(volumeToMount.Pod.UID) if podExists { // Skip running pods if !dswp.isPodTerminated(pod) { continue } if dswp.keepTerminatedPodVolumes { continue } } // Once a pod has been deleted from kubelet pod manager, do not delete // it immediately from volume manager. Instead, check the kubelet // containerRuntime to verify that all containers in the pod have been // terminated. if !runningPodsFetched { var getPodsErr error runningPods, getPodsErr = dswp.kubeContainerRuntime.GetPods(false) if getPodsErr != nil { klog.Errorf( &quot;kubeContainerRuntime.findAndRemoveDeletedPods returned error %v.&quot;, getPodsErr) continue } runningPodsFetched = true dswp.timeOfLastGetPodStatus = time.Now() } runningContainers := false for _, runningPod := range runningPods { if runningPod.ID == volumeToMount.Pod.UID { if len(runningPod.Containers) &gt; 0 { runningContainers = true } break } } if runningContainers { klog.V(4).Infof( &quot;Pod %q still has one or more containers in the non-exited state. Therefore, it will not be removed from desired state.&quot;, format.Pod(volumeToMount.Pod)) continue } exists, _, _ := dswp.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName) if !exists &amp;&amp; podExists { klog.V(4).Infof( volumeToMount.GenerateMsgDetailed(fmt.Sprintf(&quot;Actual state has not yet has this volume mounted information and pod (%q) still exists in pod manager, skip removing volume from desired state&quot;, format.Pod(volumeToMount.Pod)), &quot;&quot;)) continue } klog.V(4).Infof(volumeToMount.GenerateMsgDetailed(&quot;Removing volume from desired state&quot;, &quot;&quot;)) dswp.desiredStateOfWorld.DeletePodFromVolume( volumeToMount.PodName, volumeToMount.VolumeName) dswp.deleteProcessedPod(volumeToMount.PodName) } podsWithError := dswp.desiredStateOfWorld.GetPodsWithErrors() for _, podName := range podsWithError { if _, podExists := dswp.podManager.GetPodByUID(types.UID(podName)); !podExists { dswp.desiredStateOfWorld.PopPodErrors(podName) } } } æ€»è€Œè¨€ä¹‹ï¼Œè¿™ä¿©çš„ç›®çš„å°±æ˜¯å°†å½“å‰èŠ‚ç‚¹çš„æœŸæœ›çŠ¶æ€ï¼ŒåŒæ­¥åˆ°DesiredStateOfWorldä¸­ï¼Œç­‰å¾…æœ‰äººå¤„ç†è¿™ä¸ªæ•°æ®ç»“æ„ã€‚ ç±»ä¼¼äºç”Ÿäº§è€… 3. Reconciler è´Ÿè´£å¯¹å½“å‰èŠ‚ç‚¹ä¸Šçš„ Volume è¿›è¡Œç®¡ç†ï¼Œå¯åŠ¨ä¸€ä¸ªreconcileå¾ªç¯ ï¼Œ åœ¨æ–¹æ³•ä¸­åˆ†ä¸‰æ¬¡å¯¹å½“å‰çŠ¶æ€å’ŒæœŸæœ›è½¬æ”¹ä¸åŒ¹é…çš„å·ï¼Œè¿›è¡Œå¸è½½ï¼ŒæŒ‚è½½ç­‰æ“ä½œã€‚ //kubelet/volumemanager/reconciler/reconciler.go func (rc *reconciler) reconciliationLoopFunc() func() { return func() { rc.reconcile() if rc.populatorHasAddedPods() &amp;&amp; !rc.StatesHasBeenSynced() { rc.sync() } } } å…¶ä¸­ sync æ–¹æ³•ï¼Œæœ€ç»ˆè¿˜æ˜¯è°ƒç”¨åˆ°äº†reconcileæ–¹æ³•ï¼Œå…·ä½“æ¥çœ‹ä»£ç  //kubelet/volumemanager/reconciler/reconciler.go func (rc *reconciler) reconcile() { //é¦–å…ˆä¿è¯åº”è¯¥è¢«å¸è½½çš„ï¼Œä½†æ˜¯ä¾ç„¶åœ¨èŠ‚ç‚¹ä¸­å­˜åœ¨å·è¢«å¸è½½ï¼Œæ¯”å¦‚åˆ é™¤äº† Pod è¿™ç§æƒ…å†µ rc.unmountVolumes() // å°†åº”è¯¥æŒ‚è½½çš„å·ï¼ŒæŒ‚è½½åˆ°åˆé€‚çš„ä½ç½® rc.mountAttachVolumes() //å°†***è®¾å¤‡***ä¸èŠ‚ç‚¹åˆ†ç¦»æˆ–è€…å¸è½½ï¼Œ è¿™ä¸ªè®¾å¤‡æ¯”å¦‚æ˜¯ CDROMç­‰ device rc.unmountDetachDevices() } unmountVolumes //kubelet/volumemanager/reconciler/reconciler.go func (rc *reconciler) unmountVolumes() { //éå†å½“å‰èŠ‚ç‚¹ä¸­æ‰€æœ‰çš„æŒ‚è½½ä¿¡æ¯ for _, mountedVolume := range rc.actualStateOfWorld.GetAllMountedVolumes() { if !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) { //å¦‚æœä¸åœ¨æœŸæœ›é‡Œé¢ï¼Œè¯´æ˜æ˜¯è¦è¢«å¸è½½çš„,æ‰§è¡Œå¸è½½åŠ¨ä½œ err := rc.operationExecutor.UnmountVolume( mountedVolume.MountedVolume, rc.actualStateOfWorld, rc.kubeletPodsDir) if err != nil &amp;&amp; !nestedpendingoperations.IsAlreadyExists(err) &amp;&amp; !exponentialbackoff.IsExponentialBackoff(err) { // Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected. // Log all other errors. klog.Errorf(mountedVolume.GenerateErrorDetailed(fmt.Sprintf(&quot;operationExecutor.UnmountVolume failed (controllerAttachDetachEnabled %v)&quot;, rc.controllerAttachDetachEnabled), err).Error()) } if err == nil { klog.Infof(mountedVolume.GenerateMsgDetailed(&quot;operationExecutor.UnmountVolume started&quot;, &quot;&quot;)) } } } } mountAttachVolumes //kubelet/volumemanager/reconciler/reconciler.go func (rc *reconciler) mountAttachVolumes() { //è·å–æ‰€æœ‰æœŸæœ›çš„å·æŒ‚è½½ä¿¡æ¯ for _, volumeToMount := range rc.desiredStateOfWorld.GetVolumesToMount() { volMounted, devicePath, err := rc.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName) //è¿™é‡Œå¾—åˆ°çš„æ˜¯ï¼Œæœ¬æœº Node èŠ‚ç‚¹çš„å®é™…ç›®å½•ï¼Œåç»­æ˜¯å°†è¿™ä¸ªç›®å½•ï¼ŒæŒ‚è½½åˆ° Pod ä¸­ã€‚ **volumeToMount.DevicePath = devicePath** if cache.IsVolumeNotAttachedError(err) { // å¦‚æœå®é™…ä¸­å·æ²¡æ³•æŒ‚è½½ï¼ŒåŸå› æ˜¯å¹¶æ²¡æœ‰ attachï¼Œå…ˆæŠŠå·Attach åˆ°æœ¬æœº node ä¸Š if rc.controllerAttachDetachEnabled || !volumeToMount.PluginIsAttachable { ....... } else { //å¤„ç† Volume çš„ Attachï¼Œä¸ºä»€ä¹ˆéœ€è¦ Attachï¼Œæ˜¯å› ä¸ºæŸäº›ç±»å‹çš„å·ï¼Œå¿…é¡»æŒ‚è½½åˆ° //æœ¬æœºçš„èŠ‚ç‚¹æ‰å¯ä»¥è¢«ä½¿ç”¨ï¼Œæ¯”å¦‚ google çš„ GCEï¼Œä¸”åªèƒ½Attach åˆ°ä¸€å°æœºå™¨ //åé¢ä¼šå…·ä½“ä»‹ç» volumeToAttach := operationexecutor.VolumeToAttach{ VolumeName: volumeToMount.VolumeName, VolumeSpec: volumeToMount.VolumeSpec, NodeName: rc.nodeName, } klog.V(5).Infof(volumeToAttach.GenerateMsgDetailed(&quot;Starting operationExecutor.AttachVolume&quot;, &quot;&quot;)) err := rc.operationExecutor.AttachVolume(volumeToAttach, rc.actualStateOfWorld) ....... } } else if !volMounted || cache.IsRemountRequiredError(err) { //éœ€è¦é‡æ–°æŒ‚è½½, å…·ä½“çš„æŒ‚è½½æ˜¯åœ¨è¿™é‡Œå±•å¼€çš„ remountingLogStr := &quot;&quot; isRemount := cache.IsRemountRequiredError(err) err := rc.operationExecutor.MountVolume( rc.waitForAttachTimeout, volumeToMount.VolumeToMount, rc.actualStateOfWorld, isRemount) ..... } else if cache.IsFSResizeRequiredError(err) &amp;&amp; //çºµå‘æ‰©å±•å·ä¿¡æ¯ï¼Œæ¯”å¦‚å¢åŠ å¤§å°ä»€ä¹ˆçš„ err := rc.operationExecutor.ExpandInUseVolume( volumeToMount.VolumeToMount, rc.actualStateOfWorld) ............ } } unmountDetachDeives //kubelet/volumemanager/reconciler/reconciler.go func (rc *reconciler) unmountDetachDevices() { //éå†å½“å‰èŠ‚ç‚¹å®é™…å·²ç»Attachçš„å·ï¼Œä½†æ˜¯æ²¡æœ‰æŒ‚è½½åˆ° PODä¸Šçš„ for _, attachedVolume := range rc.actualStateOfWorld.GetUnmountedVolumes() { // å¦‚æœéœ€è¦è°ƒè° if !rc.desiredStateOfWorld.VolumeExists(attachedVolume.VolumeName) &amp;&amp; !rc.operationExecutor.IsOperationPending(attachedVolume.VolumeName, nestedpendingoperations.EmptyUniquePodName, nestedpendingoperations.EmptyNodeName) { //å¦‚æœè®¾å¤‡å·²ç»æŒ‚è½½äº†ï¼Œå¸è½½ if attachedVolume.DeviceMayBeMounted() { // Volume is globally mounted to device, unmount it err := rc.operationExecutor.UnmountDevice( attachedVolume.AttachedVolume, rc.actualStateOfWorld, rc.hostutil) ...... } else { // å·å·²ç»Attachåˆ°èŠ‚ç‚¹ä¸Šäº†ï¼ŒDetachå®ƒ if rc.controllerAttachDetachEnabled || !attachedVolume.PluginIsAttachable { rc.actualStateOfWorld.MarkVolumeAsDetached(attachedVolume.VolumeName, attachedVolume.NodeName) } else { //detach err := rc.operationExecutor.DetachVolume( attachedVolume.AttachedVolume, false /* verifySafeToDetach */, rc.actualStateOfWorld) ...... } } } } æœ¬ç¯‡ä¸»è¦è®¨è®ºæŒ‚è½½Mount çš„äº‹æƒ…ï¼Œé‡ç‚¹æ¥çœ‹ MountVolume æ˜¯æ€ä¹ˆè¿›è¡Œçš„. ä»ä¸Šé¢ä»£ç æ¥çœ‹ï¼ŒæŒ‚è½½çš„æ“ä½œäº¤ç”±äº† operationExecutor æ¥æ‰§è¡Œçš„ã€‚ 4. operationExecutor operationExecutor æ˜¯æœ¬reconcilerçš„ä¸€ä¸ªå±æ€§, æŒ‡å‘äº†OperationExecutorçš„ä¸€ä¸ªæ¥å£ï¼Œä¸»è¦åŠŸèƒ½å¦‚ä¸‹ //volume/util/operationexecutor/operation_executor.go type OperationExecutor interface { //é™„ç€å· AttachVolume(volumeToAttach VolumeToAttach, actualStateOfWorld ActualStateOfWorldAttacherUpdater) error VerifyVolumesAreAttachedPerNode(AttachedVolumes []AttachedVolume, nodeName types.NodeName, actualStateOfWorld ActualStateOfWorldAttacherUpdater) error VerifyVolumesAreAttached(volumesToVerify map[types.NodeName][]AttachedVolume, actualStateOfWorld ActualStateOfWorldAttacherUpdater) //è§£é™„ç€ DetachVolume(volumeToDetach AttachedVolume, verifySafeToDetach bool, actualStateOfWorld ActualStateOfWorldAttacherUpdater) error //æŒ‚è½½å· MountVolume(waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater, isRemount bool) error //è§£æŒ‚ UnmountVolume(volumeToUnmount MountedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater, podsDir string) error //è®¾å¤‡è§£æŒ‚ UnmountDevice(deviceToDetach AttachedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater, hostutil hostutil.HostUtils) error VerifyControllerAttachedVolume(volumeToMount VolumeToMount, nodeName types.NodeName, actualStateOfWorld ActualStateOfWorldAttacherUpdater) error IsOperationPending(volumeName v1.UniqueVolumeName, podName volumetypes.UniquePodName, nodeName types.NodeName) bool ExpandInUseVolume(volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater) error ReconstructVolumeOperation(volumeMode v1.PersistentVolumeMode, plugin volume.VolumePlugin, mapperPlugin volume.BlockVolumePlugin, uid types.UID, podName volumetypes.UniquePodName, volumeSpecName string, volumePath string, pluginName string) (*volume.Spec, error) CheckVolumeExistenceOperation(volumeSpec *volume.Spec, mountPath, volumeName string, mounter mount.Interface, uniqueVolumeName v1.UniqueVolumeName, podName volumetypes.UniquePodName, podUID types.UID, attachable volume.AttachableVolumePlugin) (bool, error) } å…·ä½“æ¥çœ‹MountVolumeæ˜¯å¦‚ä½•å®ç°çš„ //volume/util/operationexecutor/operation_executor.go func (oe *operationExecutor) MountVolume( waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater, isRemount bool) error { //è·å–å½“å‰å·æ˜¯ä»€ä¹ˆç±»å‹çš„å· fsVolume, err := util.CheckVolumeModeFilesystem(volumeToMount.VolumeSpec) if err != nil { return err } var generatedOperations volumetypes.GeneratedOperations if fsVolume { //å¦‚æœæ˜¯æ–‡ä»¶ç³»ç»Ÿï¼Œé‚£ä¹ˆè¿”å›ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿç”¨çš„å‡½æ•° generatedOperations = oe.operationGenerator.GenerateMountVolumeFunc( waitForAttachTimeout, volumeToMount, actualStateOfWorld, isRemount) } else { //å¦‚æœæ˜¯å—è®¾å¤‡ï¼Œè¿”å›å—è®¾å¤‡çš„æŒ‚è½½å‡½æ•° generatedOperations, err = oe.operationGenerator.GenerateMapVolumeFunc( waitForAttachTimeout, volumeToMount, actualStateOfWorld) } if err != nil { return err } podName := nestedpendingoperations.EmptyUniquePodName //å¼€å§‹æŒ‚è½½ï¼Œæœ€ç»ˆæ‰§è¡Œï¼Œæ˜¯ç”¨ä¸Šé¢è¿”å›çš„ä¸¤ä¸ªå‡½æ•°æ¥è¿›è¡Œçš„ return oe.pendingOperations.Run( volumeToMount.VolumeName, podName, &quot;&quot; /* nodeName */, generatedOperations) } æ–‡ä»¶ç³»ç»Ÿå’Œå—è®¾å¤‡æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ æ–‡ä»¶ç³»ç»Ÿæ˜¯ linux åœ¨å—è®¾å¤‡ä¹‹ä¸Šå°è£…äº†ä¸€å±‚é€šç”¨çš„æ¥å£ï¼Œå¯èƒ½ä¼šæ¶‰åŠåˆ°æ–‡ä»¶ç¼“å­˜ä¹‹ç±»çš„ï¼Œå—è®¾å¤‡æ›´é è¿‘äºåº•å±‚ï¼Œæ¯”å¦‚æ•°æ®åº“è¿™æ ·çš„è½¯ä»¶ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡æ“ä½œå—è®¾å¤‡æ¥è¿›è¡Œå­˜å‚¨ï¼Œç»•è¿‡æ“ä½œç³»ç»Ÿçš„ç¼“å­˜ã€‚ GenerateMountVolumeFunc ç”¨æ¥å¤„ç†æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿçš„ GenerateMapVolumeFunc ç”¨æ¥å¤„ç†å—è®¾å¤‡çš„ï¼ŒæŠŠ device æ˜ å°„ä¸€ä¸‹ æ¥çœ‹MountVolumeçš„ Func //volume/util/operationexecutor/operation_generator.go func (og *operationGenerator) GenerateMountVolumeFunc( waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater, isRemount bool) volumetypes.GeneratedOperations { //ä»å½“å‰çš„æ’ä»¶ä½“ç³»ä¸­ï¼Œè·å–åˆ°è¿™ä¸ªå·å¯¹åº”çš„æ’ä»¶å®ç° volumePluginName := unknownVolumePlugin volumePlugin, err := og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec) mountVolumeFunc := func() (error, error) { //è·å–æ’ä»¶å®ç° volumePlugin, err := og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec) //æ£€æŸ¥äº²ç¼˜æ€§ affinityErr := checkNodeAffinity(og, volumeToMount) ...... //ç”Ÿæˆä¸€ä¸ª Mounterï¼Œè¿™é‡Œæ˜¯æ’ä»¶çš„é€šç”¨æ¥å£ volumeMounter, newMounterErr := volumePlugin.NewMounter( volumeToMount.VolumeSpec, volumeToMount.Pod, volume.VolumeOptions{}) //å¦‚æœæœ‰Attacherï¼Œå…ˆæ‰§è¡Œ attacher attachableVolumePlugin, _ := og.volumePluginMgr.FindAttachablePluginBySpec(volumeToMount.VolumeSpec) var volumeAttacher volume.Attacher if attachableVolumePlugin != nil { volumeAttacher, _ = attachableVolumePlugin.NewAttacher() } // å¦‚æœæœ‰è®¾å¤‡æŒ‚è½½ï¼Œå¤„ç†è®¾å¤‡æŒ‚è½½ deviceMountableVolumePlugin, _ := og.volumePluginMgr.FindDeviceMountablePluginBySpec(volumeToMount.VolumeSpec) var volumeDeviceMounter volume.DeviceMounter if deviceMountableVolumePlugin != nil { volumeDeviceMounter, _ = deviceMountableVolumePlugin.NewDeviceMounter() } //æƒé™ä¹‹ç±»çš„ var fsGroup *int64 var fsGroupChangePolicy *v1.PodFSGroupChangePolicy if podSc := volumeToMount.Pod.Spec.SecurityContext; podSc != nil { if podSc.FSGroup != nil { fsGroup = podSc.FSGroup } if podSc.FSGroupChangePolicy != nil { fsGroupChangePolicy = podSc.FSGroupChangePolicy } } //è¿™å°±æ˜¯æœ¬æœºçš„å¾…æŒ‚è½½çš„è·¯å¾„ devicePath := volumeToMount.DevicePath if volumeAttacher != nil { //å¦‚æœéœ€è¦ Attach åˆ°æœ¬æœºçš„å·ï¼Œé‚£ä¹ˆå®é™… mount çš„è·¯å¾„æ˜¯ attach ä¹‹åçš„è·¯å¾„ devicePath, err = volumeAttacher.WaitForAttach( volumeToMount.VolumeSpec, devicePath, volumeToMount.Pod, waitForAttachTimeout) ....... } if volumeDeviceMounter != nil { //è·å–è®¾å¤‡æŒ‚è½½è·¯å¾„ï¼Œ deviceMountPath, err := volumeDeviceMounter.GetDeviceMountPath(volumeToMount.VolumeSpec) // æŒ‚è½½è®¾å¤‡ err = volumeDeviceMounter.MountDevice( volumeToMount.VolumeSpec, devicePath, deviceMountPath) //æ›´æ–°å®é™…æŒ‚è½½çŠ¶æ€ markDeviceMountedErr := actualStateOfWorld.MarkDeviceAsMounted( volumeToMount.VolumeName, devicePath, deviceMountPath) if markDeviceMountedErr != nil { // On failure, return error. Caller will log and retry. return volumeToMount.GenerateError(&quot;MountVolume.MarkDeviceAsMounted failed&quot;, markDeviceMountedErr) } ...... } if og.checkNodeCapabilitiesBeforeMount { if canMountErr := volumeMounter.CanMount(); canMountErr != nil { err = fmt.Errorf( &quot;Verify that your node machine has the required components before attempting to mount this volume type. %s&quot;, canMountErr) return volumeToMount.GenerateError(&quot;MountVolume.CanMount failed&quot;, err) } } // æ‰§è¡ŒæŒ‚è½½æ“ä½œ mountErr := volumeMounter.SetUp(volume.MounterArgs{ FsUser: ioutil.FsUserFrom(volumeToMount.Pod), FsGroup: fsGroup, DesiredSize: volumeToMount.DesiredSizeLimit, FSGroupChangePolicy: fsGroupChangePolicy, }) ...... //åç»­ä¸€å †å¤„ç†ï¼Œä¿®æ­£å®é™…çš„æŒ‚è½½çŠ¶æ€ } 5. plugins ä»ä¸Šè¿°ä»£ç æ¥çœ‹ï¼ŒæŒ‚è½½çš„æ“ä½œï¼Œæ˜¯äº¤ç»™äº†æ’ä»¶å»çœŸæ­£æ‰§è¡Œçš„ï¼Œæ’ä»¶çš„æ¥å£æè¿°å¦‚ä¸‹ //volume/volume.go type Volume interface { //å‡†å¤‡æŠŠå·æŒ‚è½½åˆ° Pod çš„å“ªä¸ªè·¯å¾„ GetPath() string MetricsProvider } //æ’ä»¶æ¥å£ type Mounter interface { // Uses Interface to provide the path for Docker binds. Volume //æ˜¯å¦å¯ä»¥æŒ‚è½½, ä¸»è¦ç”¨äºæ ¡éªŒä¸€ä¸‹ CanMount() error //æ‰§è¡ŒæŒ‚è½½æ“ä½œ SetUp(mounterArgs MounterArgs) error //æ‰§è¡ŒæŒ‚è½½æ“ä½œï¼Œä¸åŒçš„æ˜¯ï¼Œå¯ä»¥æŒ‡å®šä¸€ä¸ªç›®å½•å»æŒ‚è½½ SetUpAt(dir string, mounterArgs MounterArgs) error //è·å–è¿™ä¸ª mounter æ’ä»¶çš„ä¸€å †å±æ€§ï¼Œå¿…é¡»åœ¨æŒ‚è½½ä¹‹åæ‰èƒ½è°ƒç”¨ GetAttributes() Attributes } kubernetesæä¾›äº†è®¸å¤šå†…ç½®çš„æ’ä»¶ï¼Œæ¯”å¦‚æœ¬åœ°æ–‡ä»¶ï¼Œnfsï¼Œäº‘å­˜å‚¨æä¾›å•†ç­‰ç­‰ã€‚ æ‰¾ä¸ªæœ€ç®€å•çš„æ’ä»¶æ¥çœ‹ä¸‹æ€ä¹ˆå®ç°çš„å§ã€‚ è¿™é‡Œé€‰ local è¿™ä¸ªæŒ‚è½½å™¨ï¼ŒæŠŠæœ¬æœºæ–‡ä»¶æŒ‚è½½åˆ° pod ä¸­å»ã€‚ //volume/local/local.go // SetUp bind mounts the directory to the volume path func (m *localVolumeMounter) SetUp(mounterArgs volume.MounterArgs) error { return m.SetUpAt(m.GetPath(), mounterArgs) } //è·å–è¦æŒ‚è½½çš„æœ¬åœ°ç›®å½• func (l *localVolume) GetPath() string { return l.plugin.host.GetPodVolumeDir(l.podUID, utilstrings.EscapeQualifiedName(localVolumePluginName), l.volName) } é¦–å…ˆè·å–æœ¬æœºè¦æŒ‚è½½åˆ°Pod é‡Œçš„è·¯å¾„ï¼Œæœ€ç»ˆä¸€é¡¿çŒ›å¦‚è™çš„æ“ä½œä¹‹åï¼Œå¾—åˆ°çš„æœ€ç»ˆè·¯å¾„ä¸º /var/lib/kubelet/pods/podçš„ UID/volumes/æ’ä»¶å/å·å å½“å‰ local çš„å·åå°±æ˜¯ï¼škubernetes.io/local-volume, å…·ä½“æ¥çœ‹æ˜¯å¦‚ä½•æŒ‚è½½çš„ //volume/local/local.go func (m *localVolumeMounter) SetUpAt(dir string, mounterArgs volume.MounterArgs) error { m.plugin.volumeLocks.LockKey(m.globalPath) defer m.plugin.volumeLocks.UnlockKey(m.globalPath) ...... //å¦‚æœæ²¡æœ‰æŒ‚è½½ç‚¹ï¼Œè¿”å› notMnt, err := mount.IsNotMountPoint(m.mounter, dir) ...... //è®¾ç½®æŒ‚è½½å‚æ•°ï¼Œè¿™é‡ŒæŒ‡å®šçš„æ˜¯ bind æŠ€æœ¯ options := []string{&quot;bind&quot;} if m.readOnly { options = append(options, &quot;ro&quot;) } mountOptions := util.JoinMountOptions(options, m.mountOptions) //è·å–æœ¬æœºçš„ç»å¯¹è·¯å¾„ globalPath := util.MakeAbsolutePath(runtime.GOOS, m.globalPath) //æ‰§è¡ŒæŒ‚è½½ err = m.mounter.Mount(globalPath, dir, &quot;&quot;, mountOptions) ...... } æœ€ç»ˆäº¤ç”±äº†mount_linux.goæ¥è¿›è¡Œ Mountæ“ä½œ . //vendor/k8s.io/utils/mount/mount_linux.go func (mounter *Mounter) MountSensitive(source string, target string, fstype string, options []string, sensitiveOptions []string) error { // Path to mounter binary if containerized mounter is needed. Otherwise, it is set to empty. // All Linux distros are expected to be shipped with a mount utility that a support bind mounts. mounterPath := &quot;&quot; bind, bindOpts, bindRemountOpts, bindRemountOptsSensitive := MakeBindOptsSensitive(options, sensitiveOptions) //å¦‚æœé‡‡ç”¨äº† bind æŠ€æœ¯ if bind { //ç›´æ¥æ‰§è¡Œäº†exe.Commandæ‰§è¡Œ mount --bind err := mounter.doMount(mounterPath, defaultMountCommand, source, target, fstype, bindOpts, bindRemountOptsSensitive) if err != nil { return err } return mounter.doMount(mounterPath, defaultMountCommand, source, target, fstype, bindRemountOpts, bindRemountOptsSensitive) } // The list of filesystems that require containerized mounter on GCI image cluster fsTypesNeedMounter := map[string]struct{}{ &quot;nfs&quot;: {}, &quot;glusterfs&quot;: {}, &quot;ceph&quot;: {}, &quot;cifs&quot;: {}, } if _, ok := fsTypesNeedMounter[fstype]; ok { mounterPath = mounter.mounterPath } return mounter.doMount(mounterPath, defaultMountCommand, source, target, fstype, options, sensitiveOptions) } //vendor/k8s.io/utils/mount/mount_linux.go func (mounter *Mounter) doMount(mounterPath string, mountCmd string, source string, target string, fstype string, options []string, sensitiveOptions []string) error { mountArgs, mountArgsLogStr := MakeMountArgsSensitive(source, target, fstype, options, sensitiveOptions) if len(mounterPath) &gt; 0 { mountArgs = append([]string{mountCmd}, mountArgs...) mountArgsLogStr = mountCmd + &quot; &quot; + mountArgsLogStr mountCmd = mounterPath } if mounter.withSystemd { mountCmd, mountArgs, mountArgsLogStr = AddSystemdScopeSensitive(&quot;systemd-run&quot;, target, mountCmd, mountArgs, mountArgsLogStr) } else { } command:= exec.Command(mountCmd, mountArgs...) output, err := command.CombinedOutput() if err != nil { klog.Errorf(&quot;Mount failed: %v\\nMounting command: %s\\nMounting arguments: %s\\nOutput: %s\\n&quot;, err, mountCmd, mountArgsLogStr, string(output)) return fmt.Errorf(&quot;mount failed: %v\\nMounting command: %s\\nMounting arguments: %s\\nOutput: %s&quot;, err, mountCmd, mountArgsLogStr, string(output)) } return err } æœ€ç»ˆæ‰§è¡Œçš„å‘½ä»¤æ˜¯ï¼š mount â€”bind æº ç›®çš„ å½“ç„¶äº†ï¼Œé™¤äº†æœ¬åœ° local æ’ä»¶ä¹‹å¤–ï¼Œk8sè¿˜å†…ç½®äº†éœ€è¦æ’ä»¶ï¼Œæ¯”å¦‚EmptyDir, ConfigMap,Secretï¼ŒNFS ç­‰ç­‰ã€‚å®ç°æ–¹å¼å¤§åŒå°å¼‚. 6. æ€»ç»“ k8såœ¨å·ç®¡ç†æ–¹é¢å¤§è‡´éœ€è¦ä»¥ä¸‹å‡ ä¸ªç»„ä»¶ Volume Manager æ˜¯å·ç®¡ç†çš„é©±åŠ¨å…¥å£ï¼Œè´Ÿè´£è°ƒè° pod å’Œ volumeï¼ŒæŠŠpod çš„é¢„æœŸå·ä¿¡æ¯ï¼Œè½¬åŒ–ä¸ºå®é™…çš„å·æŒ‚è½½ã€‚ Volume plugins ä¸€ä¸ªæ’ä»¶ä½“ç³»ï¼Œæä¾›äº†æ‰©å±•æ¥å£ï¼ŒåŒ…å«äº†å„ç±»å­˜å‚¨æä¾›è€…çš„pluginså®ç° pv/pvc Controller è¿è¡Œåœ¨ Master ä¸Šçš„ç»„ä»¶ï¼Œä¸»è¦åšprovision/delete, å…¶ä»–æ–‡ç« å†ä»‹ç» Attach/Detach Controller è¿è¡Œåœ¨ master ä¸Šï¼Œä¸»è¦åšä¸€äº›å—è®¾å¤‡çš„Attachå’ŒDetachï¼Œ æ¯”å¦‚ä¸€äº›è®¾å¤‡GCE ç­‰ï¼Œå¿…é¡»å…ˆAttachåˆ°æœ¬æœºèŠ‚ç‚¹ï¼Œä¹‹åæ‰èƒ½è¢«ä½¿ç”¨ å·æŒ‚è½½çš„ä¸»è¦æµç¨‹å¤§æ¦‚æ˜¯è¿™æ ·çš„ ç”¨æˆ·åˆ›å»º Podï¼Œæä¾›ä¸€ä¸ª PVC ä¿¡æ¯ Pod è¢«åˆ†é…åˆ°èŠ‚ç‚¹ NodeA kubeletç­‰å¾… Volume Manager æŒ‚è½½å®Œæˆ (è¿˜æœ‰å…¶ä»–çš„ä¸€å †ç­‰å¾…ï¼Œæ¯”å¦‚ç½‘ç»œ) PV Controller åˆ›å»ºæŒä¹…åŒ–å·å¹¶åœ¨ç³»ç»Ÿä¸­åˆ›å»º PV å¯¹è±¡ï¼Œä»¥åŠç»‘å®š PVC Attach/Detach Controller é€šè¿‡æ’ä»¶å®ç°å—è®¾å¤‡çš„æŒ‚è½½ Volume Manager å°†æœ¬æœº node èŠ‚ç‚¹çš„ç›®å½•ï¼ŒæŒ‚è½½åˆ° Podä¸­ã€‚æ‰§è¡Œçš„æ˜¯mountå‘½ä»¤ã€‚ kubelet åœ¨å¯åŠ¨å®¹å™¨çš„æ—¶å€™ï¼Œ é€šè¿‡ CRI æ¥å£ï¼Œå°†å‚æ•°ä¼ é€’ç»™ CRI çš„å®ç°è€…ï¼Œæ¯”å¦‚ dockerï¼Œdocker æ‰§è¡Œdocker -v æŠŠ Pod çš„å·ä¿¡æ¯ï¼Œå†æ¬¡é€šè¿‡ bind mount æŠ€æœ¯ï¼Œæ˜ å°„åˆ°å®¹å™¨ä¸­å» Podç»‘å®š Volume æ˜¯æŠŠæœ¬åœ°ç›®å½•æŒ‚è½½åˆ° Pod ä¸­ï¼Œå¹¶æ²¡æœ‰ç»™å®¹å™¨ å®¹å™¨ç»‘å®šå·ï¼Œæ˜¯åœ¨å¯åŠ¨å®¹å™¨StartContainerçš„æ—¶å€™ï¼ŒæŠŠ Pod çš„å·ä¿¡æ¯ bind ç»™å®¹å™¨çš„ ","link":"http://kzltime.cn/post/volume-manager/"},{"title":"Hello Gridea","content":"ğŸ‘ æ¬¢è¿ä½¿ç”¨ Gridea ï¼ âœï¸ Gridea ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ... Github Gridea ä¸»é¡µ ç¤ºä¾‹ç½‘ç«™ ç‰¹æ€§ğŸ‘‡ ğŸ“ ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ Markdown è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ ğŸŒ‰ ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡ ğŸ·ï¸ ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„ ğŸ“‹ ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå• ğŸ’» ä½ å¯ä»¥åœ¨ Windowsï¼ŒMacOS æˆ– Linux è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯ ğŸŒ ä½ å¯ä»¥ä½¿ç”¨ ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ æˆ– Coding Pages å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å° ğŸ’¬ ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ Gitalk æˆ– DisqusJS è¯„è®ºç³»ç»Ÿ ğŸ‡¬ğŸ‡§ ä½ å¯ä»¥ä½¿ç”¨ä¸­æ–‡ç®€ä½“æˆ–è‹±è¯­ ğŸŒ ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ› ğŸ–¥ ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥ ğŸŒ± å½“ç„¶ Gridea è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´ å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼ ğŸ˜˜ Enjoy~ ","link":"http://kzltime.cn/post/hello-gridea/"}]}