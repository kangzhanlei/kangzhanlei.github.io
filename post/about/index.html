<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Kzl Time">
<meta name="description" content="Less is More">
<meta name="theme-color" content="#000">
<title>å…³äº | Kzl Time </title>
<link rel="shortcut icon" href="/favicon.ico?v=1611479784986">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?1f1588ceb7745cb9b51c447b1853159b";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


  <meta name="description" content="å…³äº" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Kzl Time </span>
            </a>  
          
        </div>
        
          <p class="subtitle">ç®€çº¦å³å¹¿é˜”</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> é¦–é¡µ
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> å½’æ¡£
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> æ ‡ç­¾
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> å…³äº
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> å‹æƒ…é“¾æ¥
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">æœç´¢</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">æ–‡ç« ç›®å½•</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">ç«™ç‚¹æ¦‚è§ˆ</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">kzl</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>å°˜ä¸–ä¸­ä¸€ä¸ªè¿·é€”å°ä¹¦ç«¥</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">2</span>
        <span class="site-item-stat-name language" data-lan="article">æ–‡ç« </span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">1</span>
        <span class="site-item-stat-name language" data-lan="category">åˆ†ç±»</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">1</span>
        <span class="site-item-stat-name language" data-lan="tag">æ ‡ç­¾</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="http://kzltime.cn/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  



</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="http://kzltime.cn/post/about/">
      å…³äº
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">å‘å¸ƒäº</span>
      <span class="publish-time" data-t="2019-01-25 19:09:48">2019-01-25</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>1<span class="language" data-lan="minute">åˆ†é’Ÿ</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>11<span class="pc-show language" data-lan="words">å­—æ•°</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p>âœï¸è¿™ä»…ä»…å°±æ˜¯ä¸€ä¸ªå­¦ä¹ ç¬”è®°</p>
<p>ğŸƒâ€â™€ğŸƒâ€â™€ğŸƒâ€â™€ğŸƒâ€â™€ğŸƒâ€â™€</p>

            </div>
            
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: 'cd042d5069b1dd0833b9',
    clientSecret: 'd6c4d43abaeafa7a6097742cf0c98e78ee959157',
    repo: 'kangzhanlei.github.io',
    owner: 'kangzhanlei',
    admin: ['kangzhanlei'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
    <footer class="footer">
        <div class="copyright">
            Powered by <a href="mailto:kangzhanlei@qq.com" target="_blank">kzl</a>
        </div>

    </footer>
    
        
                <div class="pisces back-to-top" id="back_to_top">
                    <i class="fa fa-arrow-up"></i>
                    
                        <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
                        </span>
                        
                </div>
                
                                    
                                                
</div>
<script>
    let sideBarOpen = 'sidebar-open';
    let body = document.body;
    let back2Top = document.querySelector('#back_to_top'),
        back2TopText = document.querySelector('#back_to_top_text'),
        drawerBox = document.querySelector('#drawer_box'),
        rightSideBar = document.querySelector('.sidebar'),
        viewport = document.querySelector('body');

    function scrollAnimation(currentY, targetY) {

        let needScrollTop = targetY - currentY
        let _currentY = currentY
        setTimeout(() => {
            const dist = Math.ceil(needScrollTop / 10)
            _currentY += dist
            window.scrollTo(_currentY, currentY)
            if (needScrollTop > 10 || needScrollTop < -10) {
                scrollAnimation(_currentY, targetY)
            } else {
                window.scrollTo(_currentY, targetY)
            }
        }, 1)
    }

    back2Top.addEventListener("click", function(e) {
        scrollAnimation(document.scrollingElement.scrollTop, 0);
        e.stopPropagation();
        return false;
    });

    window.addEventListener('scroll', function(e) {
        let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
        if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
            back2Top.classList.add('back-top-active');
        }
        if (percent == 0) {
            back2Top.classList.remove('back-top-active');
        }
        if (back2TopText) {
            back2TopText.textContent = Math.floor(percent);
        }
    });


    let hasCacu = false;
    window.onresize = function() {
        calcuHeight();
    }

    function calcuHeight() {
        // åŠ¨æ€è°ƒæ•´ç«™ç‚¹æ¦‚è§ˆé«˜åº¦
        if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
            let sideBar = document.querySelector('.sidebar');
            let navUl = document.querySelector('#site_nav');
            sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
            hasCacu = true;
        }
    }
    calcuHeight();

    let open = false,
        MOTION_TIME = 300,
        RIGHT_MOVE_DIS = '320px';

    if (drawerBox) {
        let rightMotions = document.querySelectorAll('.right-motion');
        let right = drawerBox.classList.contains('right');

        let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

        let openProp, closeProp;
        if (right) {
            openProp = {
                paddingRight: RIGHT_MOVE_DIS
            };
            closeProp = {
                paddingRight: '0px'
            };
        } else {
            openProp = {
                paddingLeft: RIGHT_MOVE_DIS
            };
            closeProp = {
                paddingLeft: '0px'
            };
        }

        drawerBox.onclick = function() {
            open = !open;
            window.Velocity(rightSideBar, 'stop');
            window.Velocity(viewport, 'stop');
            window.Velocity(rightMotions, 'stop');
            if (open) {
                window.Velocity(rightSideBar, {
                    width: RIGHT_MOVE_DIS
                }, {
                    duration: MOTION_TIME,
                    begin: function() {
                        window.Velocity(rightMotions, transitionDir, {});
                    }
                })
                window.Velocity(viewport, openProp, {
                    duration: MOTION_TIME
                });
            } else {
                window.Velocity(rightSideBar, {
                    width: '0px'
                }, {
                    duration: MOTION_TIME,
                    begin: function() {
                        window.Velocity(rightMotions, {
                            opacity: 0
                        });
                    }
                })
                window.Velocity(viewport, closeProp, {
                    duration: MOTION_TIME
                });
            }
            for (let i = 0; i < drawerBox.children.length; i++) {
                drawerBox.children[i].classList.toggle('muse-line');
            }
            drawerBox.classList.toggle(sideBarOpen);
        }
    }

    // é“¾æ¥è·³è½¬
    let newWindow = 'false'
    if (newWindow === 'true') {
        let links = document.querySelectorAll('.post-body a')
        links.forEach(item => {
            if (!item.classList.contains('btn')) {
                item.setAttribute("target", "_blank");
            }
        })
    }

    let faSearch = document.querySelector('#fa_search');
    faSearch.addEventListener('click', function() {
        document.querySelector('#search_mask').style = ''
    })

    // ä»£ç é«˜äº®
    hljs.initHighlightingOnLoad();

    // ç¦»å¼€å½“å‰é¡µtitleå˜åŒ–
    var leaveTitle = "";
    if (leaveTitle) {
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState == 'hidden') {
                normal_title = document.title;
                document.title = leaveTitle;
            } else {
                document.title = normal_title;
            }
        });
    }
</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
    let images = document.querySelectorAll('.section img');
    console.log(images);
    images.forEach(image => {
        var parent = image.parentElement;
        var next = image.nextElementSibling;
        parent.removeChild(image);
        var aelem = document.createElement('a');
        aelem.href = image.src;
        aelem.dataset['fancybox'] = 'images';
        aelem.dataset['rel'] = 'fancybox-button';
        aelem.classList.add('fancybox');
        aelem.appendChild(image);
        parent.insertBefore(aelem, next);
    })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>æ„Ÿè°¢æ‚¨çš„æ”¯æŒï¼Œæˆ‘ä¼šç»§ç»­åŠªåŠ›çš„!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">æ‰«ç æ‰“èµï¼Œä½ è¯´å¤šå°‘å°±å¤šå°‘</p>
      <p class="reward-tip">æ‰“å¼€å¾®ä¿¡æ‰«ä¸€æ‰«ï¼Œå³å¯è¿›è¡Œæ‰«ç æ‰“èµå“¦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="æœç´¢">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">æ¡ç›¸å…³æ¡ç›®ï¼Œä½¿ç”¨äº†</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">æ¯«ç§’</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://kzltime.cn/post/kubernetes-probe-manager/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;æ‰€æœ‰çš„ç›¸å…³ä»£ç ï¼Œéƒ½åŸºäºkubernetes v1.19.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1-å¯åŠ¨æ¢æµ‹&#34;&gt;1. å¯åŠ¨æ¢æµ‹&lt;/h1&gt;
&lt;p&gt;kubeletè´Ÿè´£å‘¨æœŸæ€§çš„è°ƒè° Podï¼Œåœ¨éœ€è¦åˆ›å»ºæ–°çš„Pod çš„æ—¶å€™ï¼Œå¯¹æ¯ä¸€ä¸ª Pod å¢åŠ ä¸€ä¸ªæ¢é’ˆæ¥æ¢æµ‹ Pod çš„çŠ¶æ€ã€‚ ä¸‹é¢æ˜¯å¯åŠ¨ä»£ç &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/kubelet.go
func (kl *Kubelet) HandlePodAdditions(pods []*v1.Pod) {
	start := kl.clock.Now()
	sort.Sort(sliceutils.PodsByCreationTime(pods))
	for _, pod := range pods {
		existingPods := kl.podManager.GetPods()
		//å¢åŠ åˆ° podManager ä¸­ï¼Œä»¥åæŸ¥è¯¢ pod éƒ½ä¼šä»è¿™é‡ŒæŸ¥
		kl.podManager.AddPod(pod)
		//å¦‚æœæ˜¯é•œåƒ Podï¼Œä»–åªæ˜¯é™æ€ Pod çš„ä¸€ä¸ªå½±å­è€Œå·²ï¼Œä¸ä¼šå‚ä¸å¢åŠ ï¼Œåˆ é™¤ä»€ä¹ˆçš„
		//å¯¹é•œåƒ Pod çš„æ“ä½œï¼Œéƒ½åªæ˜¯å¯¹é™æ€ Pod çš„ä¸€æ¬¡åˆ·æ–°è€Œå·²
		if kubetypes.IsMirrorPod(pod) {
			kl.handleMirrorPod(pod, start)
			continue
		}

		if !kl.podIsTerminated(pod) {
			activePods := kl.filterOutTerminatedPods(existingPods)
			//æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦å¯ä»¥æ¥å—æ–°çš„ Pod ç”³è¯·
			if ok, reason, message := kl.canAdmitPod(activePods, pod); !ok {
				kl.rejectPod(pod, reason, message)
				continue
			}
		}
		mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)
		//äº¤ç»™ worker å»å¤„ç† Pod çš„æ–°å¢äº‹å®œï¼Œè¿™é‡Œæš‚ä¸”ä¸å…³æ³¨
		kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)
		//æœ¬ç« çš„é‡ç‚¹ï¼Œå°†æ–°å¢çš„ Pod åŠ å…¥åˆ°probeManagerä¸­å»
		**kl.probeManager.AddPod(pod)**
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-probemanager&#34;&gt;2. probeManager&lt;/h1&gt;
&lt;p&gt;probeManager ä¸»è¦å¯¹ Pod è¿›è¡Œå¯ç”¨æ€§çš„æ¢æµ‹ï¼Œ å…·ä½“æ¥çœ‹&lt;code&gt;AddPod&lt;/code&gt;æ˜¯æ€ä¹ˆå¤„ç†çš„&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/probe/prober_manager.go
func (m *manager) AddPod(pod *v1.Pod) {
	//å› ä¸ºå¯èƒ½åŒæ—¶è¦å¤„ç†å¤šä¸ª podï¼ŒåŠ é”
	m.workerLock.Lock()
	defer m.workerLock.Unlock()

	key := probeKey{podUID: pod.UID}
	//è·å–æ‰€æœ‰çš„å®¹å™¨
	for _, c := range pod.Spec.Containers {
		key.containerName = c.Name
		//å¦‚æœæ”¯æŒStartupProbe
		if c.StartupProbe != nil &amp;amp;&amp;amp; utilfeature.DefaultFeatureGate.Enabled(features.StartupProbe) {
			key.probeType = startup
			if _, ok := m.workers[key]; ok {
				klog.Errorf(&amp;quot;Startup probe already exists! %v - %v&amp;quot;,
					format.Pod(pod), c.Name)
				return
			}
			w := newWorker(m, startup, pod, c)
			m.workers[key] = w
			go w.run()
		}
		//å¤„ç† ReadnessProbe
		if c.ReadinessProbe != nil {
			key.probeType = readiness
			if _, ok := m.workers[key]; ok {
				klog.Errorf(&amp;quot;Readiness probe already exists! %v - %v&amp;quot;,
					format.Pod(pod), c.Name)
				return
			}
			w := newWorker(m, readiness, pod, c)
			m.workers[key] = w
			go w.run()
		}
		//å¤„ç† LivenessProbe
		if c.LivenessProbe != nil {
			key.probeType = liveness
			if _, ok := m.workers[key]; ok {
				klog.Errorf(&amp;quot;Liveness probe already exists! %v - %v&amp;quot;,
					format.Pod(pod), c.Name)
				return
			}
			w := newWorker(m, liveness, pod, c)
			m.workers[key] = w
			go w.run()
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ä»ä»£ç ä¸Šæ¥çœ‹, probeManager æ”¯æŒä¸‰ç§ç±»å‹çš„æ¢é’ˆ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;StartupProbe&lt;/li&gt;
&lt;li&gt;ReadinessProbe&lt;/li&gt;
&lt;li&gt;LivenessProbe&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä¸ç®¡æ˜¯ä»€ä¹ˆç±»å‹çš„æ¢é’ˆ,æœ€ç»ˆéƒ½æ˜¯ä¸º&lt;code&gt;æ¯ä¸ªå®¹å™¨äº§ç”Ÿäº†ä¸€ä¸ªæ–°çš„ worker&lt;/code&gt; æ¥å¤„ç†çš„.&lt;/p&gt;
&lt;h1 id=&#34;3-worker&#34;&gt;3. worker&lt;/h1&gt;
&lt;p&gt;æ¥çœ‹ä¸‹ worker æ˜¯åšä»€ä¹ˆç”¨çš„&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// kubelet/probe/worker.go
func newWorker(
	m *manager,
	probeType probeType,
	pod *v1.Pod,
	container v1.Container) *worker {
	//æ„é€ ä¸€ä¸ª worker å¯¹è±¡
	w := &amp;amp;worker{
		stopCh:       make(chan struct{}, 1), // Buffer so stop() can be non-blocking.
		pod:          pod,
		container:    container,
		probeType:    probeType,
		probeManager: m,
	}

	switch probeType {
	case readiness:
		w.spec = container.ReadinessProbe
		//æ¢æµ‹çš„ç»“æœæ”¾åˆ°readnessManagerä¸­
		w.resultsManager = m.readinessManager
		w.initialValue = results.Failure
	case liveness:
		w.spec = container.LivenessProbe
		//æ¢æµ‹çš„ç»“æœæ”¾åˆ°livenessManagerä¸­
		w.resultsManager = m.livenessManager
		w.initialValue = results.Success
	case startup:
		w.spec = container.StartupProbe
		//æ¢æµ‹çš„ç»“æœæ”¾åˆ°startupManagerä¸­
		w.resultsManager = m.startupManager
		w.initialValue = results.Unknown
	}
	......
	return w
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;åœ¨æ„é€  worker çš„æ—¶å€™,ä¸åŒç±»å‹çš„æ¢é’ˆ, æœ€ç»ˆçš„æ¢æµ‹ç»“æœäº¤ç»™äº†ä¸åŒçš„ &lt;code&gt;resultManager&lt;/code&gt; å»å¤„ç†.  ä¸‹é¢æ¥çœ‹ä¸‹ä»–çš„ Run æ–¹æ³•æ˜¯å¦‚ä½•è¿›è¡Œå®¹å™¨æ¢æµ‹çš„&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// kubelet/probe/worker.go

func (w *worker) run() {
	probeTickerPeriod := time.Duration(w.spec.PeriodSeconds) * time.Second
	time.Sleep(time.Duration(rand.Float64() * float64(probeTickerPeriod)))
	//ä¸€ä¸ª ticker, æ¯éš”ä¸€å®šçš„æ—¶é—´å»æ¢æµ‹ä¸€æ¬¡
	probeTicker := time.NewTicker(probeTickerPeriod)

	defer func() {
		// å¦‚æœå…³é—­äº† pod, æ‰€æœ‰çš„æ¢æµ‹éƒ½å¯ä»¥å–æ¶ˆäº†
		probeTicker.Stop()
		if !w.containerID.IsEmpty() {
			w.resultsManager.Remove(w.containerID)
		}

		w.probeManager.removeWorker(w.pod.UID, w.container.Name, w.probeType)
		ProberResults.Delete(w.proberResultsSuccessfulMetricLabels)
		ProberResults.Delete(w.proberResultsFailedMetricLabels)
		ProberResults.Delete(w.proberResultsUnknownMetricLabels)
	}()

probeLoop:
	//æ¯éš”ä¸€å®šçš„æ—¶é—´å»æ‰§è¡Œ doProbe å»æ¢æµ‹,å¦‚æœä¸»åŠ¨è¦æ±‚åœæ­¢,åˆ™é€€å‡ºå¾ªç¯
	for w.doProbe() {
		// Wait for next probe tick.
		select {
		case &amp;lt;-w.stopCh:
			break probeLoop
		case &amp;lt;-probeTicker.C:
			// continue
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;æ¢æµ‹çš„é‡ç‚¹è½¬ç§»åˆ°äº†doProbeæ–¹æ³•, æ¥çœ‹ä¸‹å…·ä½“çš„å®ç°&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// kubelet/probe/worker.go
func (w *worker) doProbe() (keepGoing bool) {
	defer func() { recover() }() // Actually eat panics (HandleCrash takes care of logging)
	defer runtime.HandleCrash(func(_ interface{}) { keepGoing = true })
	//è·å– pod çš„çŠ¶æ€,è·å–ä¸åˆ°å°±ç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯
	status, ok := w.probeManager.statusManager.GetPodStatus(w.pod.UID)
	if !ok {
		return true
	}

	//å¦‚æœ Pod å…³é—­äº†æˆ–è€…ç»ˆæ­¢äº†,é‚£ä¹ˆæ¢æµ‹å™¨æˆ–è€…ä¹Ÿæ²¡ç”¨,å°±ä¸æ¢æµ‹äº†,è¿”å› false è‡ªåŠ¨ç»ˆæ­¢
	if status.Phase == v1.PodFailed || status.Phase == v1.PodSucceeded {
		return false
	}
	//è·å–å®¹å™¨çš„çŠ¶æ€,å¦‚æœä¸å­˜åœ¨,ç»§ç»­ç­‰ç€
	c, ok := podutil.GetContainerStatus(status.ContainerStatuses, w.container.Name)
	if !ok || len(c.ContainerID) == 0 {
		return true // Wait for more information.
	}
	//è¿™é‡Œé‡ç‚¹è¯´æ˜ä¸€ä¸‹æ˜¯ä»€ä¹ˆæ„æ€
	//Pod æ¢æµ‹å®¹å™¨çš„çŠ¶æ€,å¦‚æœå®¹å™¨å¯åŠ¨ä¸æˆåŠŸ,kubelet ä¼šå°è¯•é‡å¯ Pod, ä¼šé‡æ–°åˆ†é…ä¸€ä¸ªå®¹å™¨çš„ ID,
	//ä½†æ˜¯ worker åªæœ‰ä¸€ä¸ª, å¦‚æœå®¹å™¨çš„ ID å’Œä¹‹å‰ä¸ä¸€è‡´äº†,è¯´æ˜äº†ä»€ä¹ˆ? è¯´æ˜äº†å®¹å™¨è¢«é‡å¯äº†,é‚£ä¹ˆè¿™é‡Œ
	//éœ€è¦è®¾ç½®onHold=false,è¡¨ç¤ºæˆ‘è¿™ä¸ª worker éœ€è¦ç­‰å¾…æ–°çš„å®¹å™¨å¯åŠ¨å®Œæˆäº†,æˆ‘å†å¼€å¯æ¢æµ‹å®ƒ, åˆ«äººå®¶è¿˜
	//æ²¡æœ‰å¯åŠ¨å‘¢,æˆ‘å°±æ‹¼å‘½çš„æ¢æµ‹,ä¸€æ¢æµ‹è¯´äººå®¶æŒ‚äº†,åˆé‡å¯,è¿˜æ²¡ç­‰åˆ°äººå®¶èµ·æ¥å‘¢,åˆæ¢æµ‹åˆé‡å¯,æ— ä¼‘æ­¢çš„å¾ªç¯äº†
	//æ‰€ä»¥è¿™é‡Œç­‰å¾…ä¸€ä¸‹å®¹å™¨å¯åŠ¨å®Œæˆä¹‹åå†è¿›è¡Œæ¢æµ‹. 
	if w.containerID.String() != c.ContainerID {
		if !w.containerID.IsEmpty() {
			w.resultsManager.Remove(w.containerID)
		}
		w.containerID = kubecontainer.ParseContainerID(c.ContainerID)
		w.resultsManager.Set(w.containerID, w.initialValue, w.pod)
		// We&#39;ve got a new container; resume probing.
		**w.onHold = false**
	}

	if w.onHold {
		//worker åœ¨ç­‰å¾…,ç›´åˆ°æ–°çš„å®¹å™¨åˆ›å»ºæˆåŠŸ
		return true
	}

	if c.State.Running == nil {
		//ä¸æ˜¯è¿è¡ŒçŠ¶æ€çš„å®¹å™¨
		if !w.containerID.IsEmpty() {
			//ç›´æ¥ç»™ä»–çš„çŠ¶æ€è®¾ç½®ä¸º Failure
			w.resultsManager.Set(w.containerID, results.Failure, w.pod)
		}
		// å¦‚æœå®¹å™¨ä¸éœ€è¦è¢«é‡å¯çš„è¯,ç›´æ¥ä¸æ¢æµ‹äº†,è¿”å› false å°±å¯ä»¥äº†
		return c.State.Terminated == nil ||
			w.pod.Spec.RestartPolicy != v1.RestartPolicyNever
	}

	//å¯åŠ¨ä¹‹åä¸ä¼šç«‹åˆ»æ¢æµ‹,æœ‰å¯èƒ½äººå®¶è¿˜æ²¡æœ‰å‡†å¤‡å¥½, ç­‰å¾…ä¸€å®šçš„æ—¶é—´ä¹‹åå†å»çœŸæ­£çš„æ¢æµ‹
	if int32(time.Since(c.State.Running.StartedAt.Time).Seconds()) &amp;lt; w.spec.InitialDelaySeconds {
		return true
	}

	if c.Started != nil &amp;amp;&amp;amp; *c.Started {
		// å¦‚æœå®¹å™¨å·²ç»èµ·æ¥äº†å¹¶ä¸”é€šè¿‡äº†æ¢é’ˆæ¢æµ‹, åœæ­¢ startupçš„æ¢æµ‹
		if w.probeType == startup {
			return true
		}
	} else {
		// å¦‚æœå®¹å™¨å°šæœªå¯åŠ¨å®Œæˆ, é‚£ä¹ˆå…¶ä»–çš„æ¢æµ‹å™¨å°±å…ˆç­‰ç­‰å†æ¢æµ‹,è¿”å› true è¡¨ç¤ºç­‰ä¸‹ä¸€ä¸ªå‘¨æœŸå†æ¥
		if w.probeType != startup {
			return true
		}
	}

	//æ‰§è¡Œæ¢æµ‹é€»è¾‘
	result, err := w.probeManager.prober.probe(w.probeType, w.pod, status, w.container, w.containerID)
	if err != nil {
	//å¤±è´¥äº†ç»§ç»­æ¢æµ‹
		return true
	}
	......
	if (result == results.Failure &amp;amp;&amp;amp; w.resultRun &amp;lt; int(w.spec.FailureThreshold)) ||
		(result == results.Success &amp;amp;&amp;amp; w.resultRun &amp;lt; int(w.spec.SuccessThreshold)) {
		//æ¢æµ‹ä¸€æ¬¡ä¸è®¤ä¸ºæ˜¯æˆåŠŸæˆ–è€…å¤±è´¥,è¦å¤šæ¢æµ‹å‡ æ¬¡,è¾¾åˆ°é˜ˆå€¼ä¹‹åæ‰å¯ä»¥è®¤ä¸ºæœ‰ç»“æœäº†,è¿™é‡ŒæŒç»­æ¢æµ‹
		return true
	}
	//æŠŠæ¢æµ‹çš„ç»“æœå†™åˆ°resultManagerä¸­,ä¸åŒçš„æ¢é’ˆæœ‰ä¸åŒçš„ resultManager
	w.resultsManager.Set(w.containerID, result, w.pod)

	if (w.probeType == liveness || w.probeType == startup) &amp;amp;&amp;amp; result == results.Failure {
		// å®¹å™¨æ¢æ´»æ¢é’ˆæ¢æµ‹å¤±è´¥çš„è¯,ä»–å°†ä¼šè¢«é‡å¯, åœæ­¢å½“å‰çš„æ¢æµ‹,ç›´åˆ°æ–°çš„å®¹å™¨é‡æ–°è¢«æ‹‰èµ·
		w.onHold = true
		w.resultRun = 0
	}

	return true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;doProbe&lt;/code&gt; ä¸»è¦åšäº†å‡ ä»¶äº‹æƒ…:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;æ ¹æ®çŠ¶æ€åˆ¤æ–­æ˜¯å¦è¦æŒç»­æ¢æµ‹&lt;/li&gt;
&lt;li&gt;æ‰§è¡Œæ¢æµ‹é€»è¾‘ ,  æ¢æµ‹ä¸€å®šçš„æ¬¡æ•°, éœ€è¦ç­‰åˆ°é˜ˆå€¼æ»¡è¶³ä¹‹åæ‰è®¤ä¸ºæœ‰äº†ç»“æœ&lt;/li&gt;
&lt;li&gt;æŠŠç»“æœå†™åˆ° resultManager ä¸­,ä¾›åˆ«äººä½¿ç”¨.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;çœŸæ­£çš„æ¢æµ‹é€»è¾‘å…¶å®æ¯”è¾ƒç®€å•,å¦‚ä¸‹&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/prober/probe.go
func (pb *prober) probe(probeType probeType, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID) (results.Result, error) {
	var probeSpec *v1.Probe
	//æ ¹æ®ä¸åŒçš„æ¢æµ‹, è®¾ç½®ä¸åŒçš„æ¢æµ‹æ–¹æ³•
	switch probeType {
	case readiness:
		probeSpec = container.ReadinessProbe
	case liveness:
		probeSpec = container.LivenessProbe
	case startup:
		probeSpec = container.StartupProbe
	default:
		return results.Failure, fmt.Errorf(&amp;quot;unknown probe type: %q&amp;quot;, probeType)
	}

	ctrName := fmt.Sprintf(&amp;quot;%s:%s&amp;quot;, format.Pod(pod), container.Name)
	if probeSpec == nil {
		klog.Warningf(&amp;quot;%s probe for %s is nil&amp;quot;, probeType, ctrName)
		return results.Success, nil
	}
	//å¼€å¯æ¢æµ‹é€»è¾‘, è¿™é‡Œå¸¦æœ‰ 5 æ¬¡é‡è¯•,å¤±è´¥äº†è‡ªå·±å¾ªç¯æ¢æµ‹
	result, output, err := pb.runProbeWithRetries(probeType, probeSpec, pod, status, container, containerID, maxProbeRetries)
	if err != nil || (result != probe.Success &amp;amp;&amp;amp; result != probe.Warning) {
		// Probe failed in one way or another.
		if err != nil {
			klog.V(1).Infof(&amp;quot;%s probe for %q errored: %v&amp;quot;, probeType, ctrName, err)
			pb.recordContainerEvent(pod, &amp;amp;container, v1.EventTypeWarning, events.ContainerUnhealthy, &amp;quot;%s probe errored: %v&amp;quot;, probeType, err)
		} else { // result != probe.Success
			klog.V(1).Infof(&amp;quot;%s probe for %q failed (%v): %s&amp;quot;, probeType, ctrName, result, output)
			pb.recordContainerEvent(pod, &amp;amp;container, v1.EventTypeWarning, events.ContainerUnhealthy, &amp;quot;%s probe failed: %s&amp;quot;, probeType, output)
		}
		return results.Failure, err
	}
	if result == probe.Warning {
		pb.recordContainerEvent(pod, &amp;amp;container, v1.EventTypeWarning, events.ContainerProbeWarning, &amp;quot;%s probe warning: %s&amp;quot;, probeType, output)
		klog.V(3).Infof(&amp;quot;%s probe for %q succeeded with a warning: %s&amp;quot;, probeType, ctrName, output)
	} else {
		klog.V(3).Infof(&amp;quot;%s probe for %q succeeded&amp;quot;, probeType, ctrName)
	}
	return results.Success, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/prober/probe.go
func (pb *prober) runProbe(probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID) (probe.Result, string, error) {
	timeout := time.Duration(p.TimeoutSeconds) * time.Second
	//å¦‚æœæ˜¯ exec æ¨¡å¼,å°±æ˜¯åœ¨å®¹å™¨é‡Œæ‰§è¡Œä¸€ä¸ªå‘½ä»¤,è¿”å›æ‰§è¡Œçš„ç»“æœ
	if p.Exec != nil {
		klog.V(4).Infof(&amp;quot;Exec-Probe Pod: %v, Container: %v, Command: %v&amp;quot;, pod.Name, container.Name, p.Exec.Command)
		command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)
		return pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))
	}
	//å¦‚æœæ˜¯ http æ¨¡å¼,æ‰§è¡Œ http è°ƒç”¨,è¿”å› code
	if p.HTTPGet != nil {
		scheme := strings.ToLower(string(p.HTTPGet.Scheme))
		host := p.HTTPGet.Host
		if host == &amp;quot;&amp;quot; {
			host = status.PodIP
		}
		port, err := extractPort(p.HTTPGet.Port, container)
		if err != nil {
			return probe.Unknown, &amp;quot;&amp;quot;, err
		}
		path := p.HTTPGet.Path
		klog.V(4).Infof(&amp;quot;HTTP-Probe Host: %v://%v, Port: %v, Path: %v&amp;quot;, scheme, host, port, path)
		url := formatURL(scheme, host, port, path)
		headers := buildHeader(p.HTTPGet.HTTPHeaders)
		klog.V(4).Infof(&amp;quot;HTTP-Probe Headers: %v&amp;quot;, headers)
		switch probeType {
		case liveness:
			return pb.livenessHTTP.Probe(url, headers, timeout)
		case startup:
			return pb.startupHTTP.Probe(url, headers, timeout)
		default:
			return pb.readinessHTTP.Probe(url, headers, timeout)
		}
	}
	//å¦‚æœæ˜¯ tcp æ¢æµ‹,ç›´æ¥æ‹¨å·,è¿”å›æ¢æµ‹ç»“æœå³å¯
	if p.TCPSocket != nil {
		port, err := extractPort(p.TCPSocket.Port, container)
		if err != nil {
			return probe.Unknown, &amp;quot;&amp;quot;, err
		}
		host := p.TCPSocket.Host
		if host == &amp;quot;&amp;quot; {
			host = status.PodIP
		}
		klog.V(4).Infof(&amp;quot;TCP-Probe Host: %v, Port: %v, Timeout: %v&amp;quot;, host, port, timeout)
		return pb.tcp.Probe(host, port, timeout)
	}
	klog.Warningf(&amp;quot;Failed to find probe builder for container: %v&amp;quot;, container)
	return probe.Unknown, &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;missing probe handler for %s:%s&amp;quot;, format.Pod(pod), container.Name)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ç»¼ä¸Š, æ¢é’ˆæœ‰ä¸‰ç§ä¸åŒçš„æ¢æµ‹æ–¹å¼&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exec è¡¨ç¤ºåœ¨å®¹å™¨å†…æ‰§è¡Œä¸€ä¸ªå‘½ä»¤,è¿”å›æ‰§è¡Œçš„ç»“æœ&lt;/li&gt;
&lt;li&gt;Http è¡¨ç¤ºæ‰§è¡Œä¸€ä¸ª http è¯·æ±‚,è¿”å›ç æ¥å†³å®šæˆåŠŸè¿˜æ˜¯å¤±è´¥&lt;/li&gt;
&lt;li&gt;Tcp è¡¨ç¤ºæ‰§è¡Œä¸€ä¸ªæ‹¨å·,æ‹¨é€šäº†å°±è®¤ä¸ºæ˜¯æˆåŠŸäº†&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-resultmanager&#34;&gt;4. resultManager&lt;/h1&gt;
&lt;p&gt;ä¸Šæ–‡æè¿°äº†æ¢é’ˆæ˜¯å¦‚ä½•æ‰§è¡Œçš„, æ‰§è¡Œåçš„ç»“æœéƒ½æ”¶é›†åˆ°äº†å¯¹åº”çš„ resultManager ä¸­,  ç±»å‹å¦‚ä¸‹:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;readinessManager&lt;/li&gt;
&lt;li&gt;livenessManager&lt;/li&gt;
&lt;li&gt;startupManager&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä¸‹é¢é’ˆå¯¹è¿™ä¸‰ç§æ¢é’ˆçš„å¤„ç†æ–¹å¼, å±•å¼€å™è¿°&lt;/p&gt;
&lt;h2 id=&#34;41-livenessmanager&#34;&gt;4.1 livenessManager&lt;/h2&gt;
&lt;p&gt;è¿™ç§ç±»å‹çš„æ¢é’ˆ, ç§°ä¸ºæ¢æ´»æ¢é’ˆ, æ„æ€æ˜¯, æ¢æµ‹çš„ç»“æœ, ç›´æ¥å†³å®šç€ Pod çš„ç”Ÿæ­», å¦‚æœæ¢æµ‹å¤±è´¥äº†, kubelet å°†ä¼šé‡å¯å®ƒ.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/prober/results/results_manager.go 
func (m *manager) Set(id kubecontainer.ContainerID, result Result, pod *v1.Pod) {
	if m.setInternal(id, result) {
		m.updates &amp;lt;- Update{id, result, pod.UID}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;è®¾ç½®å®¹å™¨çš„æ¢æµ‹ç»“æœ, å…¶å®å°±æ˜¯æŠŠä¸€ä¸ª &lt;code&gt;Update&lt;/code&gt;ç»“æ„ä½“, æ”¾å…¥äº†updatesçš„ channel ä¸­å». æœ‰äººæ”¾,è‚¯å®šæœ‰äººè¯», é‚£ä¹ˆè°è¯»äº†å‘¢?  kubelet å»è¯», æ¥çœ‹ä»£ç &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/kubelet.go

// æˆªå–syncLoopIterationæ–¹æ³•, å¤§å¾ªç¯ä¸­çš„ä¸€éƒ¨åˆ†,å…·ä½“ä»£ç åˆ†æè§ kubelet å¯åŠ¨ç¯‡
case update := &amp;lt;-kl.livenessManager.Updates():
		if update.Result == proberesults.Failure {
			// The liveness manager detected a failure; sync the pod.

			// We should not use the pod from livenessManager, because it is never updated after
			// initialization.
			pod, ok := kl.podManager.GetPodByUID(update.PodUID)
			if !ok {
				// If the pod no longer exists, ignore the update.
				klog.V(4).Infof(&amp;quot;SyncLoop (container unhealthy): ignore irrelevant update: %#v&amp;quot;, update)
				break
			}
			klog.V(1).Infof(&amp;quot;SyncLoop (container unhealthy): %q&amp;quot;, format.Pod(pod))
			handler.HandlePodSyncs([]*v1.Pod{pod})
		}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kubelet å¯åŠ¨ä¹‹å, ä¼šä»livenessManagerçš„æ¢æµ‹ç»“æœä¸­è¯»å– &lt;code&gt;Update&lt;/code&gt; , å¦‚æœæœ‰å®¹å™¨å¤±è´¥äº†, é‚£ä¹ˆä¼šè·å–è¿™ä¸ªå®¹å™¨å¯¹åº”çš„ Pod, ç„¶åè°ƒç”¨&lt;code&gt;HandlePodSyncs&lt;/code&gt;æ–¹æ³•, æ€æ­»è¿™ä¸ª pod,ç„¶åé‡æ–°æ‹‰èµ·ä¸€ä¸ªæ–°çš„ Pod. å…·ä½“çš„ä»£ç è§ kubelet, è¿™é‡Œä¸å†å±•å¼€äº†.&lt;/p&gt;
&lt;h2 id=&#34;42-readinessmanager&#34;&gt;4.2 readinessManager&lt;/h2&gt;
&lt;p&gt;è¿™ç§ç±»å‹çš„æ¢é’ˆ,ç§°ä¸ºå°±ç»ªæ¢é’ˆ, æ„æ€æ˜¯, å½“å®¹å™¨å‡†å¤‡å¥½äº†,å¯ä»¥æ¥å—è¯·æ±‚äº†, æ¯”å¦‚ service å°±æ˜¯åœ¨å°±ç»ªæ¢é’ˆæœ‰äº†ç»“æœçš„æƒ…å†µä¸‹, æ‰ä¼šæŠŠæµé‡è½¬å‘åˆ° Pod ä¸­æ¥. ä¸ç„¶æ²¡æœ‰å°±ç»ªå°±è½¬å‘æµé‡,å¯èƒ½ä¼šé€ æˆæµé‡ä¸¢å¤±.&lt;/p&gt;
&lt;p&gt;åœ¨prober_managerå¯åŠ¨çš„æ—¶å€™, æ‰§è¡Œäº†ä»¥ä¸‹é€»è¾‘&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/prober/prober_manager.go 
func (m *manager) Start() {
	// Start syncing readiness.
	go wait.Forever(m.updateReadiness, 0)
	// Start syncing startup.
	go wait.Forever(m.updateStartup, 0)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;å¯åŠ¨äº†ä¸¤ä¸ªå¾ªç¯, ä¸åœçš„æ¢æµ‹&lt;code&gt;updateReadiness&lt;/code&gt; å’Œ &lt;code&gt;updateStartup&lt;/code&gt; , ä¸‹é¢æ¥çœ‹ updateReadinessæ˜¯å¦‚ä½•å¤„ç†çš„&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/prober/prober_manager.go 
func (m *manager) updateReadiness() {
	//ä»channel ä¸­è·å–çŠ¶æ€å˜åŒ–
	update := &amp;lt;-m.readinessManager.Updates()
	//è·å–çŠ¶æ€ 
	ready := update.Result == results.Success
	//é€šè¿‡statusManagerè®¾ç½®çŠ¶æ€ , äº¤ç»™äº†statusManagerå»å¤„ç†. å…·ä½“çš„è§statusManageré€»è¾‘
	m.statusManager.SetContainerReadiness(update.PodUID, update.ContainerID, ready)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ä»ä¸Šè¯‰ä»£ç æ¥çœ‹, å°±ç»ªæ¢é’ˆæŠŠå®¹å™¨çš„æ¢æµ‹ç»“æœ, ç»Ÿä¸€äº¤ç»™äº†statusManageræ¥å¤„ç†. å…·ä½“çš„é€»è¾‘è§statusManager. ç®€å•æ¥è¯´å°±æ˜¯æŠŠçŠ¶æ€æ›´æ–°åˆ° etcd, ç„¶å service ä¼šæ ¹æ®çŠ¶æ€æ¥åšè¿›ä¸€æ­¥çš„åˆ¤æ–­.&lt;/p&gt;
&lt;h2 id=&#34;43-startupmanager&#34;&gt;4.3 startupManager&lt;/h2&gt;
&lt;p&gt;å’Œreadinesså¤„ç†é€»è¾‘å‡ ä¹ä¸€è‡´, ä¸å±•å¼€å™è¿°&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/prober/prober_manager.go 
func (m *manager) updateStartup() {
	update := &amp;lt;-m.startupManager.Updates()

	started := update.Result == results.Success
	m.statusManager.SetContainerStartup(update.PodUID, update.ContainerID, started)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-æ€»ç»“&#34;&gt;5. æ€»ç»“&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;livenessProbe ç”¨æ¥æ¢æ´», æ£€æŸ¥å®¹å™¨æ˜¯å¦è¿˜åœ¨è¿è¡Œ, å¯ä»¥ä¸º pod ä¸­çš„æ¯ä¸ªå®¹å™¨è®¾ç½®å­˜æ´»æ¢é’ˆ. å¦‚æœæ¢æµ‹å¤±è´¥, kubernetes å°†å®šæœŸçš„æ‰§è¡Œæ¢é’ˆå¹¶é‡æ–°å¯åŠ¨å®¹å™¨&lt;/li&gt;
&lt;li&gt;readinessProbe å°±ç»ªæ¢é’ˆç”¨æ¥ç¡®å®š, ç‰¹å®šçš„ pod æ˜¯å¦å¯ä»¥æ¥å—å®¢æˆ·ç«¯çš„è¯·æ±‚, å½“å®¹å™¨å°±ç»ªæ¢é’ˆè¿”å›æˆåŠŸæ—¶, è¡¨ç¤ºå®¹å™¨å·²ç»å‡†å¤‡å¥½æ¥å—è¯·æ±‚äº†.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;å¯åŠ¨å®¹å™¨æ—¶ï¼Œå¯ä»¥ä¸ºKubernetesé…ç½®ä¸€ä¸ªç­‰å¾…æ—¶é—´ï¼Œç»è¿‡ç­‰å¾…æ—¶é—´åæ‰å¯ä»¥æ‰§è¡Œç¬¬ä¸€æ¬¡å‡†å¤‡å°±ç»ªæ£€æŸ¥ã€‚ä¹‹åï¼Œå®ƒä¼šå‘¨æœŸæ€§åœ°è°ƒç”¨æ¢é’ˆï¼Œå¹¶æ ¹æ®å°±ç»ªæ¢é’ˆçš„ç»“æœé‡‡å–è¡ŒåŠ¨ã€‚å¦‚æœæŸä¸ªpodæŠ¥å‘Šå®ƒå°šæœªå‡†å¤‡å°±ç»ªï¼Œåˆ™ä¼šä»è¯¥æœåŠ¡ä¸­åˆ é™¤è¯¥podã€‚å¦‚æœpodå†æ¬¡å‡†å¤‡å°±ç»ªï¼Œåˆ™é‡æ–°æ·»åŠ podã€‚ä¸å­˜æ´»æ¢é’ˆä¸åŒï¼Œå¦‚æœå®¹å™¨æœªé€šè¿‡å‡†å¤‡æ£€æŸ¥ï¼Œåˆ™ä¸ä¼šè¢«ç»ˆæ­¢æˆ–é‡æ–°å¯åŠ¨ã€‚è¿™æ˜¯å­˜æ´»æ¢é’ˆä¸å°±ç»ªæ¢é’ˆä¹‹é—´çš„é‡è¦åŒºåˆ«ã€‚å­˜æ´»æ¢é’ˆé€šè¿‡æ€æ­»å¼‚å¸¸çš„å®¹å™¨å¹¶ç”¨æ–°çš„æ­£å¸¸å®¹å™¨æ›¿ä»£å®ƒä»¬æ¥ä¿æŒpodæ­£å¸¸å·¥ä½œï¼Œè€Œå°±ç»ªæ¢é’ˆç¡®ä¿åªæœ‰å‡†å¤‡å¥½å¤„ç†è¯·æ±‚çš„podæ‰å¯ä»¥æ¥æ”¶å®ƒä»¬ï¼ˆè¯·æ±‚ï¼‰ã€‚è¿™åœ¨å®¹å™¨å¯åŠ¨æ—¶æœ€ä¸ºå¿…è¦ï¼Œå½“ç„¶åœ¨å®¹å™¨è¿è¡Œä¸€æ®µæ—¶é—´åä¹Ÿæ˜¯æœ‰ç”¨çš„ã€‚&lt;/p&gt;
&lt;p&gt;æ¢é’ˆæ”¯æŒæ˜¯ä¸‰ç§æ¢æµ‹å®¹å™¨çš„æœºåˆ¶&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Http Get æ¢é’ˆå¯¹å®¹å™¨çš„ IP åœ°å€(è‡ªå·±æŒ‡å®šçš„ç«¯å£å’Œè·¯å¾„) æ‰§è¡Œ Http Get è¯·æ±‚, å¦‚æœæ¢æµ‹æˆåŠŸ, ä¸”å“åº”ä»£ç ä¸ä»£è¡¨é”™è¯¯, åˆ™è®¤ä¸ºæ¢æµ‹æˆåŠŸ, å¦åˆ™è®¤ä¸ºå¤±è´¥,å®¹å™¨å°†è¢«é‡æ–°å¯åŠ¨&lt;/li&gt;
&lt;li&gt;Tcpå¥—æ¥å­—å°è¯•ä¸å®¹å™¨æŒ‡å®šçš„ç«¯å£å»ºç«‹ tcp è¿æ¥,å¦‚æœè¿æ¥å»ºç«‹æˆåŠŸ,æ¢æµ‹æˆåŠŸ&lt;/li&gt;
&lt;li&gt;Exec åœ¨å®¹å™¨å†…æ‰§è¡Œä»»æ„å‘½ä»¤,å¹¶æ£€æŸ¥å‘½ä»¤çš„é€€å‡ºçŠ¶æ€ç , å¦‚æœçŠ¶æ€ç æ˜¯ 0 , è¡¨ç¤ºæ¢æµ‹æˆåŠŸ. å…¶ä»–è¢«è®¤ä¸ºæ¢æµ‹å¤±è´¥&lt;/li&gt;
&lt;/ul&gt;
">kuberneteså­¦ä¹ ç¬”è®° -  Probe Manager</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://kzltime.cn/post/volume-manager/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;æ‰€æœ‰çš„ç›¸å…³ä»£ç ï¼Œéƒ½åŸºäºkubernetes v1.19.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1-è¿è¡ŒåŸç†&#34;&gt;1. è¿è¡ŒåŸç†&lt;/h1&gt;
&lt;p&gt;kubeletå¯åŠ¨æ—¶ä¼šè°ƒç”¨&lt;code&gt;volumeMananger&lt;/code&gt;çš„ &lt;code&gt;Run&lt;/code&gt; æ–¹æ³•å¯åŠ¨å·ç®¡ç†å™¨ã€‚ å®ƒè´Ÿè´£åœ¨å½“å‰èŠ‚ç‚¹çš„ Pod å’Œ Volume å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œå¯¹ Volume è¿›è¡ŒæŒ‚è½½å’Œå¸è½½ç­‰æ“ä½œã€‚&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (vm *volumeManager) Run(sourcesReady config.SourcesReady, stopCh &amp;lt;-chan struct{}) {
	defer runtime.HandleCrash()
	go vm.desiredStateOfWorldPopulator.Run(sourcesReady, stopCh)
	go vm.reconciler.Run(stopCh)
	metrics.Register(vm.actualStateOfWorld, vm.desiredStateOfWorld, vm.volumePluginMgr)
	if vm.kubeClient != nil {
		vm.volumePluginMgr.Run(stopCh)
	}
	&amp;lt;-stopCh
	klog.Infof(&amp;quot;Shutting down Kubelet Volume Manager&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ä¸»è¦åšä¸¤ä»¶äº‹æƒ…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;desiredStateOfWorldPopulatorä¸»è¦è´Ÿè´£ä» API server ä¸­è·å– Pod çš„ä¿¡æ¯ï¼Œå°†ä»–ä»¬æ›´æ–°åˆ°æœ¬åœ°çš„ä¸€ä¸ª&lt;code&gt;DesiredStateOfWorld&lt;/code&gt;çš„æ•°æ®ç»“æ„ä¸­ã€‚&lt;/li&gt;
&lt;li&gt;reconciler è´Ÿè´£è°ƒè°ï¼Œä¹Ÿå°±æ˜¯æ ¹æ®&lt;code&gt;DesiredStateOfWorld&lt;/code&gt; çš„çŠ¶æ€å˜æ›´ï¼Œæ›´æ–°å®é™…çš„æŒ‚è½½ä¿¡æ¯ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;åœ¨ Pod çš„å¯åŠ¨è¿‡ç¨‹ä¸­ï¼Œå¦‚æœéœ€è¦æŒ‚è½½å·ï¼Œåˆ™é¦–å…ˆç­‰å¾…å·æŒ‚è½½å®Œæˆä¹‹åï¼Œæ‰å¯ä»¥ç»§ç»­å‘ä¸‹è¿›è¡Œã€‚&lt;/p&gt;
&lt;h1 id=&#34;2-desiredstateofworld&#34;&gt;2. DesiredStateOfWorld&lt;/h1&gt;
&lt;p&gt;æ‰§è¡Œä¸€ä¸ªå¤§å¾ªç¯ï¼Œ åšçš„äº‹æƒ…å¤§è‡´ä¹Ÿæœ‰ä¸¤ä¸ª&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;findAndAddNewPods&lt;/li&gt;
&lt;li&gt;findAndRemoveDeletedPods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;é€šè¿‡ä»¥ä¸Šä¸¤ä¸ªæ–¹æ³•ï¼Œåˆ†åˆ«è·å–èŠ‚ç‚¹ä¸­è¢«æ·»åŠ çš„æ–° Pod æˆ–è€…å·²ç»åˆ é™¤çš„è€çš„ Podï¼Œè·å–åˆ° Pod ä¹‹åä¼šæ ¹æ®å½“å‰çš„çŠ¶æ€ä¿®æ”¹æœŸæœ›çŠ¶æ€&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;findAndAddNewPods&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/volumemanager/populator/desired_state_of_world_populator.go

func (dswp *desiredStateOfWorldPopulator) findAndAddNewPods() {
	// Map unique pod name to outer volume name to MountedVolume.
	mountedVolumesForPod := make(map[volumetypes.UniquePodName]map[string]cache.MountedVolume)
	......
	processedVolumesForFSResize := sets.NewString()

	//è·å–æ‰€æœ‰çš„ pod æ•°æ®
	for _, pod := range dswp.podManager.GetPods() {
		//å¦‚æœæ˜¯ç»ˆæ­¢çš„ podï¼Œä¸ç”¨æŒ‚è½½å·
		if dswp.isPodTerminated(pod) {
			continue
		}
		//å¤„ç†ç‰¹å®šçš„ pod çš„å·ä¿¡æ¯ï¼ŒæŠŠä»–ä»¬æ”¾åˆ°ä¸€ä¸ªdesired stateçš„æ•°æ®ç»“æ„é‡Œå»
		dswp.processPodVolumes(pod, mountedVolumesForPod, processedVolumesForFSResize)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (dswp *desiredStateOfWorldPopulator) processPodVolumes(
	pod *v1.Pod,
	mountedVolumesForPod map[volumetypes.UniquePodName]map[string]cache.MountedVolume,
	processedVolumesForFSResize sets.String) {
	if pod == nil {
		return
	}
	//è·å– pod çš„UID
	uniquePodName := util.GetUniquePodName(pod)
	//åœ¨å½“å‰processedPodsä¸­ç¼“å­˜æœ‰è¿™ä¸ª pod çš„ä¿¡æ¯ï¼Œå°±ä¸å¤„ç†äº†
	if dswp.podPreviouslyProcessed(uniquePodName) {
		return
	}

	allVolumesAdded := true
	mounts, devices := util.GetPodVolumeNames(pod)

	expandInUsePV := utilfeature.DefaultFeatureGate.Enabled(features.ExpandInUsePersistentVolumes)
	// ä» Pod çš„å®šä¹‰ä¸­æ‹¿åˆ°æ‰€æœ‰çš„å¾…ç»‘å®šçš„å·ä¿¡æ¯
	for _, podVolume := range pod.Spec.Volumes {
		if !mounts.Has(podVolume.Name) &amp;amp;&amp;amp; !devices.Has(podVolume.Name) {
			continue
		}

	//åˆ›å»ºå·ä¿¡æ¯, åç»­å†å…·ä½“åˆ†æè¿™ä¸ªä»£ç 
		pvc, volumeSpec, volumeGidValue, err :=
			dswp.createVolumeSpec(podVolume, pod, mounts, devices)
		if err != nil {
			dswp.desiredStateOfWorld.AddErrorToPod(uniquePodName, err.Error())
			allVolumesAdded = false
			continue
		}

		// æŠŠå·ä¿¡æ¯æ·»åŠ åˆ°æ•°æ®ç»“æ„ä¸­
		_, err = dswp.desiredStateOfWorld.AddPodToVolume(
			uniquePodName, pod, volumeSpec, podVolume.Name, volumeGidValue)
		if err != nil {
			dswp.desiredStateOfWorld.AddErrorToPod(uniquePodName, err.Error())
			allVolumesAdded = false
		} else {
		}

		if expandInUsePV {
			dswp.checkVolumeFSResize(pod, podVolume, pvc, volumeSpec,
				uniquePodName, mountedVolumesForPod, processedVolumesForFSResize)
		}
	}

	//å¦‚æœæ‰€æœ‰çš„å·éƒ½å¤„ç†å®Œæ¯•äº†ï¼Œæ ‡è®°å¤„ç†å®Œæˆ
	if allVolumesAdded {
		dswp.markPodProcessed(uniquePodName)
		// New pod has been synced. Re-mount all volumes that need it
		// (e.g. DownwardAPI)
		dswp.actualStateOfWorld.MarkRemountRequired(uniquePodName)
		// Remove any stored errors for the pod, everything went well in this processPodVolumes
		dswp.desiredStateOfWorld.PopPodErrors(uniquePodName)
	} else if dswp.podHasBeenSeenOnce(uniquePodName) {
		// For the Pod which has been processed at least once, even though some volumes
		// may not have been reprocessed successfully this round, we still mark it as processed to avoid
		// processing it at a very high frequency. The pod will be reprocessed when volume manager calls
		// ReprocessPod() which is triggered by SyncPod.
		dswp.markPodProcessed(uniquePodName)
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;åšçš„ä¸»è¦çš„äº‹æƒ…å°±æ˜¯å°†èŠ‚ç‚¹åŠ å…¥çš„æ–° Pod æ·»åŠ åˆ°&lt;code&gt;DesiredStateOfWorld&lt;/code&gt; ä¸­ã€‚&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;findAndRemoveDeletedPods&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (dswp *desiredStateOfWorldPopulator) findAndRemoveDeletedPods() {
	var runningPods []*kubecontainer.Pod

	runningPodsFetched := false
	for _, volumeToMount := range dswp.desiredStateOfWorld.GetVolumesToMount() {
		pod, podExists := dswp.podManager.GetPodByUID(volumeToMount.Pod.UID)
		if podExists {
			// Skip running pods
			if !dswp.isPodTerminated(pod) {
				continue
			}
			if dswp.keepTerminatedPodVolumes {
				continue
			}
		}

		// Once a pod has been deleted from kubelet pod manager, do not delete
		// it immediately from volume manager. Instead, check the kubelet
		// containerRuntime to verify that all containers in the pod have been
		// terminated.
		if !runningPodsFetched {
			var getPodsErr error
			runningPods, getPodsErr = dswp.kubeContainerRuntime.GetPods(false)
			if getPodsErr != nil {
				klog.Errorf(
					&amp;quot;kubeContainerRuntime.findAndRemoveDeletedPods returned error %v.&amp;quot;,
					getPodsErr)
				continue
			}

			runningPodsFetched = true
			dswp.timeOfLastGetPodStatus = time.Now()
		}

		runningContainers := false
		for _, runningPod := range runningPods {
			if runningPod.ID == volumeToMount.Pod.UID {
				if len(runningPod.Containers) &amp;gt; 0 {
					runningContainers = true
				}

				break
			}
		}

		if runningContainers {
			klog.V(4).Infof(
				&amp;quot;Pod %q still has one or more containers in the non-exited state. Therefore, it will not be removed from desired state.&amp;quot;,
				format.Pod(volumeToMount.Pod))
			continue
		}
		exists, _, _ := dswp.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName)
		if !exists &amp;amp;&amp;amp; podExists {
			klog.V(4).Infof(
				volumeToMount.GenerateMsgDetailed(fmt.Sprintf(&amp;quot;Actual state has not yet has this volume mounted information and pod (%q) still exists in pod manager, skip removing volume from desired state&amp;quot;,
					format.Pod(volumeToMount.Pod)), &amp;quot;&amp;quot;))
			continue
		}
		klog.V(4).Infof(volumeToMount.GenerateMsgDetailed(&amp;quot;Removing volume from desired state&amp;quot;, &amp;quot;&amp;quot;))

		dswp.desiredStateOfWorld.DeletePodFromVolume(
			volumeToMount.PodName, volumeToMount.VolumeName)
		dswp.deleteProcessedPod(volumeToMount.PodName)
	}

	podsWithError := dswp.desiredStateOfWorld.GetPodsWithErrors()
	for _, podName := range podsWithError {
		if _, podExists := dswp.podManager.GetPodByUID(types.UID(podName)); !podExists {
			dswp.desiredStateOfWorld.PopPodErrors(podName)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æ€»è€Œè¨€ä¹‹ï¼Œè¿™ä¿©çš„ç›®çš„å°±æ˜¯å°†å½“å‰èŠ‚ç‚¹çš„æœŸæœ›çŠ¶æ€ï¼ŒåŒæ­¥åˆ°DesiredStateOfWorldä¸­ï¼Œç­‰å¾…æœ‰äººå¤„ç†è¿™ä¸ªæ•°æ®ç»“æ„ã€‚ ç±»ä¼¼äº&lt;code&gt;ç”Ÿäº§è€…&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-reconciler&#34;&gt;3. Reconciler&lt;/h1&gt;
&lt;p&gt;è´Ÿè´£å¯¹å½“å‰èŠ‚ç‚¹ä¸Šçš„ Volume è¿›è¡Œç®¡ç†ï¼Œå¯åŠ¨ä¸€ä¸ª&lt;code&gt;reconcile&lt;/code&gt;å¾ªç¯ ï¼Œ åœ¨æ–¹æ³•ä¸­åˆ†ä¸‰æ¬¡å¯¹å½“å‰çŠ¶æ€å’ŒæœŸæœ›è½¬æ”¹ä¸åŒ¹é…çš„å·ï¼Œè¿›è¡Œå¸è½½ï¼ŒæŒ‚è½½ç­‰æ“ä½œã€‚&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/volumemanager/reconciler/reconciler.go

func (rc *reconciler) reconciliationLoopFunc() func() {
	return func() {
		rc.reconcile()
		if rc.populatorHasAddedPods() &amp;amp;&amp;amp; !rc.StatesHasBeenSynced() {
			rc.sync()
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;å…¶ä¸­ sync æ–¹æ³•ï¼Œæœ€ç»ˆè¿˜æ˜¯è°ƒç”¨åˆ°äº†reconcileæ–¹æ³•ï¼Œå…·ä½“æ¥çœ‹ä»£ç &lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/volumemanager/reconciler/reconciler.go
func (rc *reconciler) reconcile() {
	//é¦–å…ˆä¿è¯åº”è¯¥è¢«å¸è½½çš„ï¼Œä½†æ˜¯ä¾ç„¶åœ¨èŠ‚ç‚¹ä¸­å­˜åœ¨å·è¢«å¸è½½ï¼Œæ¯”å¦‚åˆ é™¤äº† Pod è¿™ç§æƒ…å†µ
	rc.unmountVolumes()
	
	// å°†åº”è¯¥æŒ‚è½½çš„å·ï¼ŒæŒ‚è½½åˆ°åˆé€‚çš„ä½ç½®
	rc.mountAttachVolumes()

	//å°†***è®¾å¤‡***ä¸èŠ‚ç‚¹åˆ†ç¦»æˆ–è€…å¸è½½ï¼Œ è¿™ä¸ªè®¾å¤‡æ¯”å¦‚æ˜¯ CDROMç­‰ device
	rc.unmountDetachDevices()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;unmountVolumes&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/volumemanager/reconciler/reconciler.go
func (rc *reconciler) unmountVolumes() {
	//éå†å½“å‰èŠ‚ç‚¹ä¸­æ‰€æœ‰çš„æŒ‚è½½ä¿¡æ¯
	for _, mountedVolume := range rc.actualStateOfWorld.GetAllMountedVolumes() {
		if !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) {
			//å¦‚æœä¸åœ¨æœŸæœ›é‡Œé¢ï¼Œè¯´æ˜æ˜¯è¦è¢«å¸è½½çš„,æ‰§è¡Œå¸è½½åŠ¨ä½œ
			err := rc.operationExecutor.UnmountVolume(
				mountedVolume.MountedVolume, rc.actualStateOfWorld, rc.kubeletPodsDir)
			if err != nil &amp;amp;&amp;amp;
				!nestedpendingoperations.IsAlreadyExists(err) &amp;amp;&amp;amp;
				!exponentialbackoff.IsExponentialBackoff(err) {
				// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
				// Log all other errors.
				klog.Errorf(mountedVolume.GenerateErrorDetailed(fmt.Sprintf(&amp;quot;operationExecutor.UnmountVolume failed (controllerAttachDetachEnabled %v)&amp;quot;, rc.controllerAttachDetachEnabled), err).Error())
			}
			if err == nil {
				klog.Infof(mountedVolume.GenerateMsgDetailed(&amp;quot;operationExecutor.UnmountVolume started&amp;quot;, &amp;quot;&amp;quot;))
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mountAttachVolumes&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/volumemanager/reconciler/reconciler.go
func (rc *reconciler) mountAttachVolumes() {
	//è·å–æ‰€æœ‰æœŸæœ›çš„å·æŒ‚è½½ä¿¡æ¯
	for _, volumeToMount := range rc.desiredStateOfWorld.GetVolumesToMount() {
		volMounted, devicePath, err := rc.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName)
		//è¿™é‡Œå¾—åˆ°çš„æ˜¯ï¼Œæœ¬æœº Node èŠ‚ç‚¹çš„å®é™…ç›®å½•ï¼Œåç»­æ˜¯å°†è¿™ä¸ªç›®å½•ï¼ŒæŒ‚è½½åˆ° Pod ä¸­ã€‚
		**volumeToMount.DevicePath = devicePath**
		if cache.IsVolumeNotAttachedError(err) {
		// å¦‚æœå®é™…ä¸­å·æ²¡æ³•æŒ‚è½½ï¼ŒåŸå› æ˜¯å¹¶æ²¡æœ‰ attachï¼Œå…ˆæŠŠå·Attach åˆ°æœ¬æœº node ä¸Š
			if rc.controllerAttachDetachEnabled || !volumeToMount.PluginIsAttachable {
			.......
			} else {
			//å¤„ç† Volume çš„ Attachï¼Œä¸ºä»€ä¹ˆéœ€è¦ Attachï¼Œæ˜¯å› ä¸ºæŸäº›ç±»å‹çš„å·ï¼Œå¿…é¡»æŒ‚è½½åˆ°
			//æœ¬æœºçš„èŠ‚ç‚¹æ‰å¯ä»¥è¢«ä½¿ç”¨ï¼Œæ¯”å¦‚ google çš„ GCEï¼Œä¸”åªèƒ½Attach åˆ°ä¸€å°æœºå™¨
			//åé¢ä¼šå…·ä½“ä»‹ç»
				volumeToAttach := operationexecutor.VolumeToAttach{
					VolumeName: volumeToMount.VolumeName,
					VolumeSpec: volumeToMount.VolumeSpec,
					NodeName:   rc.nodeName,
				}
				klog.V(5).Infof(volumeToAttach.GenerateMsgDetailed(&amp;quot;Starting operationExecutor.AttachVolume&amp;quot;, &amp;quot;&amp;quot;))
				err := rc.operationExecutor.AttachVolume(volumeToAttach, rc.actualStateOfWorld)
				.......
			}
		} else if !volMounted || cache.IsRemountRequiredError(err) {
			//éœ€è¦é‡æ–°æŒ‚è½½, å…·ä½“çš„æŒ‚è½½æ˜¯åœ¨è¿™é‡Œå±•å¼€çš„
			remountingLogStr := &amp;quot;&amp;quot;
			isRemount := cache.IsRemountRequiredError(err)
			err := rc.operationExecutor.MountVolume(
				rc.waitForAttachTimeout,
				volumeToMount.VolumeToMount,
				rc.actualStateOfWorld,
				isRemount)
			.....
		} else if cache.IsFSResizeRequiredError(err) &amp;amp;&amp;amp;
			//çºµå‘æ‰©å±•å·ä¿¡æ¯ï¼Œæ¯”å¦‚å¢åŠ å¤§å°ä»€ä¹ˆçš„
			err := rc.operationExecutor.ExpandInUseVolume(
				volumeToMount.VolumeToMount,
				rc.actualStateOfWorld)
				............
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unmountDetachDeives&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//kubelet/volumemanager/reconciler/reconciler.go
func (rc *reconciler) unmountDetachDevices() {
//éå†å½“å‰èŠ‚ç‚¹å®é™…å·²ç»Attachçš„å·ï¼Œä½†æ˜¯æ²¡æœ‰æŒ‚è½½åˆ° PODä¸Šçš„
	for _, attachedVolume := range rc.actualStateOfWorld.GetUnmountedVolumes() {
		// å¦‚æœéœ€è¦è°ƒè°
		if !rc.desiredStateOfWorld.VolumeExists(attachedVolume.VolumeName) &amp;amp;&amp;amp;
			!rc.operationExecutor.IsOperationPending(attachedVolume.VolumeName, nestedpendingoperations.EmptyUniquePodName, nestedpendingoperations.EmptyNodeName) {
			//å¦‚æœè®¾å¤‡å·²ç»æŒ‚è½½äº†ï¼Œå¸è½½
			if attachedVolume.DeviceMayBeMounted() {
				// Volume is globally mounted to device, unmount it

				err := rc.operationExecutor.UnmountDevice(
					attachedVolume.AttachedVolume, rc.actualStateOfWorld, rc.hostutil)
				 ......
			} else {
				// å·å·²ç»Attachåˆ°èŠ‚ç‚¹ä¸Šäº†ï¼ŒDetachå®ƒ
				if rc.controllerAttachDetachEnabled || !attachedVolume.PluginIsAttachable {
					rc.actualStateOfWorld.MarkVolumeAsDetached(attachedVolume.VolumeName, attachedVolume.NodeName)
				} else {
					//detach
					err := rc.operationExecutor.DetachVolume(
						attachedVolume.AttachedVolume, false /* verifySafeToDetach */, rc.actualStateOfWorld)
					......
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æœ¬ç¯‡ä¸»è¦è®¨è®ºæŒ‚è½½&lt;code&gt;Mount&lt;/code&gt; çš„äº‹æƒ…ï¼Œé‡ç‚¹æ¥çœ‹ &lt;code&gt;MountVolume&lt;/code&gt;  æ˜¯æ€ä¹ˆè¿›è¡Œçš„.  ä»ä¸Šé¢ä»£ç æ¥çœ‹ï¼ŒæŒ‚è½½çš„æ“ä½œäº¤ç”±äº† &lt;code&gt;operationExecutor&lt;/code&gt; æ¥æ‰§è¡Œçš„ã€‚&lt;/p&gt;
&lt;h1 id=&#34;4-operationexecutor&#34;&gt;4. operationExecutor&lt;/h1&gt;
&lt;p&gt;operationExecutor æ˜¯æœ¬reconcilerçš„ä¸€ä¸ªå±æ€§, æŒ‡å‘äº†OperationExecutorçš„ä¸€ä¸ªæ¥å£ï¼Œä¸»è¦åŠŸèƒ½å¦‚ä¸‹&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//volume/util/operationexecutor/operation_executor.go

type OperationExecutor interface {
	//é™„ç€å·
	AttachVolume(volumeToAttach VolumeToAttach, actualStateOfWorld ActualStateOfWorldAttacherUpdater) error
	VerifyVolumesAreAttachedPerNode(AttachedVolumes []AttachedVolume, nodeName types.NodeName, actualStateOfWorld ActualStateOfWorldAttacherUpdater) error
	VerifyVolumesAreAttached(volumesToVerify map[types.NodeName][]AttachedVolume, actualStateOfWorld ActualStateOfWorldAttacherUpdater)
	//è§£é™„ç€
	DetachVolume(volumeToDetach AttachedVolume, verifySafeToDetach bool, actualStateOfWorld ActualStateOfWorldAttacherUpdater) error
	//æŒ‚è½½å·
	MountVolume(waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater, isRemount bool) error
	//è§£æŒ‚
	UnmountVolume(volumeToUnmount MountedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater, podsDir string) error
	//è®¾å¤‡è§£æŒ‚
	UnmountDevice(deviceToDetach AttachedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater, hostutil hostutil.HostUtils) error
	VerifyControllerAttachedVolume(volumeToMount VolumeToMount, nodeName types.NodeName, actualStateOfWorld ActualStateOfWorldAttacherUpdater) error
	IsOperationPending(volumeName v1.UniqueVolumeName, podName volumetypes.UniquePodName, nodeName types.NodeName) bool
	ExpandInUseVolume(volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater) error
	ReconstructVolumeOperation(volumeMode v1.PersistentVolumeMode, plugin volume.VolumePlugin, mapperPlugin volume.BlockVolumePlugin, uid types.UID, podName volumetypes.UniquePodName, volumeSpecName string, volumePath string, pluginName string) (*volume.Spec, error)
	CheckVolumeExistenceOperation(volumeSpec *volume.Spec, mountPath, volumeName string, mounter mount.Interface, uniqueVolumeName v1.UniqueVolumeName, podName volumetypes.UniquePodName, podUID types.UID, attachable volume.AttachableVolumePlugin) (bool, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;å…·ä½“æ¥çœ‹MountVolumeæ˜¯å¦‚ä½•å®ç°çš„&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//volume/util/operationexecutor/operation_executor.go
func (oe *operationExecutor) MountVolume(
	waitForAttachTimeout time.Duration,
	volumeToMount VolumeToMount,
	actualStateOfWorld ActualStateOfWorldMounterUpdater,
	isRemount bool) error {
	//è·å–å½“å‰å·æ˜¯ä»€ä¹ˆç±»å‹çš„å·
	fsVolume, err := util.CheckVolumeModeFilesystem(volumeToMount.VolumeSpec)
	if err != nil {
		return err
	}
	var generatedOperations volumetypes.GeneratedOperations
	if fsVolume {
		//å¦‚æœæ˜¯æ–‡ä»¶ç³»ç»Ÿï¼Œé‚£ä¹ˆè¿”å›ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿç”¨çš„å‡½æ•°
		generatedOperations = oe.operationGenerator.GenerateMountVolumeFunc(
			waitForAttachTimeout, volumeToMount, actualStateOfWorld, isRemount)

	} else {
		//å¦‚æœæ˜¯å—è®¾å¤‡ï¼Œè¿”å›å—è®¾å¤‡çš„æŒ‚è½½å‡½æ•° 
		generatedOperations, err = oe.operationGenerator.GenerateMapVolumeFunc(
			waitForAttachTimeout, volumeToMount, actualStateOfWorld)
	}
	if err != nil {
		return err
	}
	podName := nestedpendingoperations.EmptyUniquePodName
	//å¼€å§‹æŒ‚è½½ï¼Œæœ€ç»ˆæ‰§è¡Œï¼Œæ˜¯ç”¨ä¸Šé¢è¿”å›çš„ä¸¤ä¸ªå‡½æ•°æ¥è¿›è¡Œçš„
	return oe.pendingOperations.Run(
		volumeToMount.VolumeName, podName, &amp;quot;&amp;quot; /* nodeName */, generatedOperations)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;æ–‡ä»¶ç³»ç»Ÿå’Œå—è®¾å¤‡æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ æ–‡ä»¶ç³»ç»Ÿæ˜¯ linux åœ¨å—è®¾å¤‡ä¹‹ä¸Šå°è£…äº†ä¸€å±‚é€šç”¨çš„æ¥å£ï¼Œå¯èƒ½ä¼šæ¶‰åŠåˆ°æ–‡ä»¶ç¼“å­˜ä¹‹ç±»çš„ï¼Œå—è®¾å¤‡æ›´é è¿‘äºåº•å±‚ï¼Œæ¯”å¦‚æ•°æ®åº“è¿™æ ·çš„è½¯ä»¶ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡æ“ä½œå—è®¾å¤‡æ¥è¿›è¡Œå­˜å‚¨ï¼Œç»•è¿‡æ“ä½œç³»ç»Ÿçš„ç¼“å­˜ã€‚&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GenerateMountVolumeFunc ç”¨æ¥å¤„ç†æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿçš„&lt;/li&gt;
&lt;li&gt;GenerateMapVolumeFunc  ç”¨æ¥å¤„ç†å—è®¾å¤‡çš„ï¼ŒæŠŠ device æ˜ å°„ä¸€ä¸‹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æ¥çœ‹MountVolumeçš„ Func&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//volume/util/operationexecutor/operation_generator.go
func (og *operationGenerator) GenerateMountVolumeFunc(
	waitForAttachTimeout time.Duration,
	volumeToMount VolumeToMount,
	actualStateOfWorld ActualStateOfWorldMounterUpdater,
	isRemount bool) volumetypes.GeneratedOperations {

	//ä»å½“å‰çš„æ’ä»¶ä½“ç³»ä¸­ï¼Œè·å–åˆ°è¿™ä¸ªå·å¯¹åº”çš„æ’ä»¶å®ç°
	volumePluginName := unknownVolumePlugin
	volumePlugin, err :=
		og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)

	mountVolumeFunc := func() (error, error) {
		//è·å–æ’ä»¶å®ç°
		volumePlugin, err := og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)
		//æ£€æŸ¥äº²ç¼˜æ€§
		affinityErr := checkNodeAffinity(og, volumeToMount)
		......
		//ç”Ÿæˆä¸€ä¸ª Mounterï¼Œè¿™é‡Œæ˜¯æ’ä»¶çš„é€šç”¨æ¥å£
		volumeMounter, newMounterErr := volumePlugin.NewMounter(
			volumeToMount.VolumeSpec,
			volumeToMount.Pod,
			volume.VolumeOptions{})
		//å¦‚æœæœ‰Attacherï¼Œå…ˆæ‰§è¡Œ attacher
			attachableVolumePlugin, _ :=
			og.volumePluginMgr.FindAttachablePluginBySpec(volumeToMount.VolumeSpec)
		var volumeAttacher volume.Attacher
		if attachableVolumePlugin != nil {
			volumeAttacher, _ = attachableVolumePlugin.NewAttacher()
		}

		// å¦‚æœæœ‰è®¾å¤‡æŒ‚è½½ï¼Œå¤„ç†è®¾å¤‡æŒ‚è½½
		deviceMountableVolumePlugin, _ := og.volumePluginMgr.FindDeviceMountablePluginBySpec(volumeToMount.VolumeSpec)
		var volumeDeviceMounter volume.DeviceMounter
		if deviceMountableVolumePlugin != nil {
			volumeDeviceMounter, _ = deviceMountableVolumePlugin.NewDeviceMounter()
		}
		//æƒé™ä¹‹ç±»çš„
		var fsGroup *int64
		var fsGroupChangePolicy *v1.PodFSGroupChangePolicy
		if podSc := volumeToMount.Pod.Spec.SecurityContext; podSc != nil {
			if podSc.FSGroup != nil {
				fsGroup = podSc.FSGroup
			}
			if podSc.FSGroupChangePolicy != nil {
				fsGroupChangePolicy = podSc.FSGroupChangePolicy
			}
		}
		//è¿™å°±æ˜¯æœ¬æœºçš„å¾…æŒ‚è½½çš„è·¯å¾„
		devicePath := volumeToMount.DevicePath
		if volumeAttacher != nil {
			//å¦‚æœéœ€è¦ Attach åˆ°æœ¬æœºçš„å·ï¼Œé‚£ä¹ˆå®é™… mount çš„è·¯å¾„æ˜¯ attach ä¹‹åçš„è·¯å¾„
			devicePath, err = volumeAttacher.WaitForAttach(
				volumeToMount.VolumeSpec, devicePath, volumeToMount.Pod, waitForAttachTimeout)
			.......
		}
		if volumeDeviceMounter != nil {
			//è·å–è®¾å¤‡æŒ‚è½½è·¯å¾„ï¼Œ
			deviceMountPath, err :=
				volumeDeviceMounter.GetDeviceMountPath(volumeToMount.VolumeSpec)
			// æŒ‚è½½è®¾å¤‡
			err = volumeDeviceMounter.MountDevice(
				volumeToMount.VolumeSpec,
				devicePath,
				deviceMountPath)
			//æ›´æ–°å®é™…æŒ‚è½½çŠ¶æ€
			markDeviceMountedErr := actualStateOfWorld.MarkDeviceAsMounted(
				volumeToMount.VolumeName, devicePath, deviceMountPath)
			if markDeviceMountedErr != nil {
				// On failure, return error. Caller will log and retry.
				return volumeToMount.GenerateError(&amp;quot;MountVolume.MarkDeviceAsMounted failed&amp;quot;, markDeviceMountedErr)
			}

			......
		}

		if og.checkNodeCapabilitiesBeforeMount {
			if canMountErr := volumeMounter.CanMount(); canMountErr != nil {
				err = fmt.Errorf(
					&amp;quot;Verify that your node machine has the required components before attempting to mount this volume type. %s&amp;quot;,
					canMountErr)
				return volumeToMount.GenerateError(&amp;quot;MountVolume.CanMount failed&amp;quot;, err)
			}
		}

		// æ‰§è¡ŒæŒ‚è½½æ“ä½œ
		mountErr := volumeMounter.SetUp(volume.MounterArgs{
			FsUser:              ioutil.FsUserFrom(volumeToMount.Pod),
			FsGroup:             fsGroup,
			DesiredSize:         volumeToMount.DesiredSizeLimit,
			FSGroupChangePolicy: fsGroupChangePolicy,
		})
		......
		//åç»­ä¸€å †å¤„ç†ï¼Œä¿®æ­£å®é™…çš„æŒ‚è½½çŠ¶æ€
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-plugins&#34;&gt;5. plugins&lt;/h1&gt;
&lt;p&gt;ä»ä¸Šè¿°ä»£ç æ¥çœ‹ï¼ŒæŒ‚è½½çš„æ“ä½œï¼Œæ˜¯äº¤ç»™äº†æ’ä»¶å»çœŸæ­£æ‰§è¡Œçš„ï¼Œæ’ä»¶çš„æ¥å£æè¿°å¦‚ä¸‹&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//volume/volume.go

type Volume interface {
	//å‡†å¤‡æŠŠå·æŒ‚è½½åˆ° Pod çš„å“ªä¸ªè·¯å¾„
	GetPath() string
	MetricsProvider
}
//æ’ä»¶æ¥å£
type Mounter interface {
	// Uses Interface to provide the path for Docker binds.
	Volume
	//æ˜¯å¦å¯ä»¥æŒ‚è½½, ä¸»è¦ç”¨äºæ ¡éªŒä¸€ä¸‹
	CanMount() error
	//æ‰§è¡ŒæŒ‚è½½æ“ä½œ
	SetUp(mounterArgs MounterArgs) error
	//æ‰§è¡ŒæŒ‚è½½æ“ä½œï¼Œä¸åŒçš„æ˜¯ï¼Œå¯ä»¥æŒ‡å®šä¸€ä¸ªç›®å½•å»æŒ‚è½½
	SetUpAt(dir string, mounterArgs MounterArgs) error
	//è·å–è¿™ä¸ª mounter æ’ä»¶çš„ä¸€å †å±æ€§ï¼Œå¿…é¡»åœ¨æŒ‚è½½ä¹‹åæ‰èƒ½è°ƒç”¨
	GetAttributes() Attributes
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kubernetesæä¾›äº†è®¸å¤šå†…ç½®çš„æ’ä»¶ï¼Œæ¯”å¦‚æœ¬åœ°æ–‡ä»¶ï¼Œnfsï¼Œäº‘å­˜å‚¨æä¾›å•†ç­‰ç­‰ã€‚ æ‰¾ä¸ªæœ€ç®€å•çš„æ’ä»¶æ¥çœ‹ä¸‹æ€ä¹ˆå®ç°çš„å§ã€‚ è¿™é‡Œé€‰ local è¿™ä¸ªæŒ‚è½½å™¨ï¼ŒæŠŠæœ¬æœºæ–‡ä»¶æŒ‚è½½åˆ° pod ä¸­å»ã€‚&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//volume/local/local.go

// SetUp bind mounts the directory to the volume path
func (m *localVolumeMounter) SetUp(mounterArgs volume.MounterArgs) error {
	return m.SetUpAt(m.GetPath(), mounterArgs)
}

//è·å–è¦æŒ‚è½½çš„æœ¬åœ°ç›®å½•
func (l *localVolume) GetPath() string {
	return l.plugin.host.GetPodVolumeDir(l.podUID, utilstrings.EscapeQualifiedName(localVolumePluginName), l.volName)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;é¦–å…ˆè·å–æœ¬æœºè¦æŒ‚è½½åˆ°Pod é‡Œçš„è·¯å¾„ï¼Œæœ€ç»ˆä¸€é¡¿çŒ›å¦‚è™çš„æ“ä½œä¹‹åï¼Œå¾—åˆ°çš„æœ€ç»ˆè·¯å¾„ä¸º&lt;/p&gt;
&lt;p&gt;/var/lib/kubelet/pods/podçš„ UID/volumes/æ’ä»¶å/å·å&lt;/p&gt;
&lt;p&gt;å½“å‰ local çš„å·åå°±æ˜¯ï¼škubernetes.io/local-volume, å…·ä½“æ¥çœ‹æ˜¯å¦‚ä½•æŒ‚è½½çš„&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//volume/local/local.go
func (m *localVolumeMounter) SetUpAt(dir string, mounterArgs volume.MounterArgs) error {
	m.plugin.volumeLocks.LockKey(m.globalPath)
	defer m.plugin.volumeLocks.UnlockKey(m.globalPath)
	......
	//å¦‚æœæ²¡æœ‰æŒ‚è½½ç‚¹ï¼Œè¿”å›
	notMnt, err := mount.IsNotMountPoint(m.mounter, dir)
	......
	//è®¾ç½®æŒ‚è½½å‚æ•°ï¼Œè¿™é‡ŒæŒ‡å®šçš„æ˜¯ bind æŠ€æœ¯
	options := []string{&amp;quot;bind&amp;quot;}
	if m.readOnly {
		options = append(options, &amp;quot;ro&amp;quot;)
	}
	mountOptions := util.JoinMountOptions(options, m.mountOptions)

	//è·å–æœ¬æœºçš„ç»å¯¹è·¯å¾„
	globalPath := util.MakeAbsolutePath(runtime.GOOS, m.globalPath)
	//æ‰§è¡ŒæŒ‚è½½
	err = m.mounter.Mount(globalPath, dir, &amp;quot;&amp;quot;, mountOptions)
	......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;æœ€ç»ˆäº¤ç”±äº†&lt;code&gt;mount_linux.go&lt;/code&gt;æ¥è¿›è¡Œ &lt;code&gt;Mount&lt;/code&gt;æ“ä½œ .&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//vendor/k8s.io/utils/mount/mount_linux.go

func (mounter *Mounter) MountSensitive(source string, target string, fstype string, options []string, sensitiveOptions []string) error {
	// Path to mounter binary if containerized mounter is needed. Otherwise, it is set to empty.
	// All Linux distros are expected to be shipped with a mount utility that a support bind mounts.
	mounterPath := &amp;quot;&amp;quot;
	bind, bindOpts, bindRemountOpts, bindRemountOptsSensitive := MakeBindOptsSensitive(options, sensitiveOptions)
	//å¦‚æœé‡‡ç”¨äº† bind æŠ€æœ¯
	if bind {
	//ç›´æ¥æ‰§è¡Œäº†exe.Commandæ‰§è¡Œ mount --bind 
		err := mounter.doMount(mounterPath, defaultMountCommand, source, target, fstype, bindOpts, bindRemountOptsSensitive)
		if err != nil {
			return err
		}
		return mounter.doMount(mounterPath, defaultMountCommand, source, target, fstype, bindRemountOpts, bindRemountOptsSensitive)
	}
	// The list of filesystems that require containerized mounter on GCI image cluster
	fsTypesNeedMounter := map[string]struct{}{
		&amp;quot;nfs&amp;quot;:       {},
		&amp;quot;glusterfs&amp;quot;: {},
		&amp;quot;ceph&amp;quot;:      {},
		&amp;quot;cifs&amp;quot;:      {},
	}
	if _, ok := fsTypesNeedMounter[fstype]; ok {
		mounterPath = mounter.mounterPath
	}
	return mounter.doMount(mounterPath, defaultMountCommand, source, target, fstype, options, sensitiveOptions)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//vendor/k8s.io/utils/mount/mount_linux.go
func (mounter *Mounter) doMount(mounterPath string, mountCmd string, source string, target string, fstype string, options []string, sensitiveOptions []string) error {
	mountArgs, mountArgsLogStr := MakeMountArgsSensitive(source, target, fstype, options, sensitiveOptions)
	if len(mounterPath) &amp;gt; 0 {
		mountArgs = append([]string{mountCmd}, mountArgs...)
		mountArgsLogStr = mountCmd + &amp;quot; &amp;quot; + mountArgsLogStr
		mountCmd = mounterPath
	}

	if mounter.withSystemd {
		mountCmd, mountArgs, mountArgsLogStr = AddSystemdScopeSensitive(&amp;quot;systemd-run&amp;quot;, target, mountCmd, mountArgs, mountArgsLogStr)
	} else {
	}
	command:= exec.Command(mountCmd, mountArgs...)
	output, err := command.CombinedOutput()
	if err != nil {
		klog.Errorf(&amp;quot;Mount failed: %v\nMounting command: %s\nMounting arguments: %s\nOutput: %s\n&amp;quot;, err, mountCmd, mountArgsLogStr, string(output))
		return fmt.Errorf(&amp;quot;mount failed: %v\nMounting command: %s\nMounting arguments: %s\nOutput: %s&amp;quot;,
			err, mountCmd, mountArgsLogStr, string(output))
	}
	return err
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;æœ€ç»ˆæ‰§è¡Œçš„å‘½ä»¤æ˜¯ï¼š &lt;code&gt;mount â€”bind æº ç›®çš„&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;å½“ç„¶äº†ï¼Œé™¤äº†æœ¬åœ° local æ’ä»¶ä¹‹å¤–ï¼Œk8sè¿˜å†…ç½®äº†éœ€è¦æ’ä»¶ï¼Œæ¯”å¦‚EmptyDir, ConfigMap,Secretï¼ŒNFS ç­‰ç­‰ã€‚å®ç°æ–¹å¼å¤§åŒå°å¼‚.&lt;/p&gt;
&lt;h1 id=&#34;6-æ€»ç»“&#34;&gt;6. æ€»ç»“&lt;/h1&gt;
&lt;p&gt;k8såœ¨å·ç®¡ç†æ–¹é¢å¤§è‡´éœ€è¦ä»¥ä¸‹å‡ ä¸ªç»„ä»¶&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Volume Manager&lt;/p&gt;
&lt;p&gt;æ˜¯å·ç®¡ç†çš„é©±åŠ¨å…¥å£ï¼Œè´Ÿè´£è°ƒè° pod å’Œ volumeï¼ŒæŠŠpod çš„é¢„æœŸå·ä¿¡æ¯ï¼Œè½¬åŒ–ä¸ºå®é™…çš„å·æŒ‚è½½ã€‚&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Volume plugins&lt;/p&gt;
&lt;p&gt;ä¸€ä¸ªæ’ä»¶ä½“ç³»ï¼Œæä¾›äº†æ‰©å±•æ¥å£ï¼ŒåŒ…å«äº†å„ç±»å­˜å‚¨æä¾›è€…çš„pluginså®ç°&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pv/pvc Controller&lt;/p&gt;
&lt;p&gt;è¿è¡Œåœ¨ Master ä¸Šçš„ç»„ä»¶ï¼Œä¸»è¦åšprovision/delete, å…¶ä»–æ–‡ç« å†ä»‹ç»&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Attach/Detach Controller&lt;/p&gt;
&lt;p&gt;è¿è¡Œåœ¨ master ä¸Šï¼Œä¸»è¦åšä¸€äº›å—è®¾å¤‡çš„Attachå’ŒDetachï¼Œ æ¯”å¦‚ä¸€äº›è®¾å¤‡GCE ç­‰ï¼Œå¿…é¡»å…ˆAttachåˆ°æœ¬æœºèŠ‚ç‚¹ï¼Œä¹‹åæ‰èƒ½è¢«ä½¿ç”¨&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;å·æŒ‚è½½çš„ä¸»è¦æµç¨‹å¤§æ¦‚æ˜¯è¿™æ ·çš„&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ç”¨æˆ·åˆ›å»º Podï¼Œæä¾›ä¸€ä¸ª PVC ä¿¡æ¯&lt;/li&gt;
&lt;li&gt;Pod è¢«åˆ†é…åˆ°èŠ‚ç‚¹ NodeA&lt;/li&gt;
&lt;li&gt;kubeletç­‰å¾… Volume Manager æŒ‚è½½å®Œæˆ (è¿˜æœ‰å…¶ä»–çš„ä¸€å †ç­‰å¾…ï¼Œæ¯”å¦‚ç½‘ç»œ)&lt;/li&gt;
&lt;li&gt;PV Controller åˆ›å»ºæŒä¹…åŒ–å·å¹¶åœ¨ç³»ç»Ÿä¸­åˆ›å»º PV å¯¹è±¡ï¼Œä»¥åŠç»‘å®š PVC&lt;/li&gt;
&lt;li&gt;Attach/Detach Controller é€šè¿‡æ’ä»¶å®ç°å—è®¾å¤‡çš„æŒ‚è½½
&lt;ul&gt;
&lt;li&gt;Volume Manager å°†æœ¬æœº node èŠ‚ç‚¹çš„ç›®å½•ï¼ŒæŒ‚è½½åˆ° Podä¸­ã€‚æ‰§è¡Œçš„æ˜¯mountå‘½ä»¤ã€‚&lt;/li&gt;
&lt;li&gt;kubelet åœ¨å¯åŠ¨å®¹å™¨çš„æ—¶å€™ï¼Œ é€šè¿‡ CRI æ¥å£ï¼Œå°†å‚æ•°ä¼ é€’ç»™ CRI çš„å®ç°è€…ï¼Œæ¯”å¦‚ dockerï¼Œdocker æ‰§è¡Œdocker -v æŠŠ Pod çš„å·ä¿¡æ¯ï¼Œå†æ¬¡é€šè¿‡ bind mount æŠ€æœ¯ï¼Œæ˜ å°„åˆ°å®¹å™¨ä¸­å»&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://kzltime.cn/post-images/1611475388513.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Podç»‘å®š Volume æ˜¯æŠŠæœ¬åœ°ç›®å½•æŒ‚è½½åˆ° Pod ä¸­ï¼Œå¹¶æ²¡æœ‰ç»™å®¹å™¨&lt;/li&gt;
&lt;li&gt;å®¹å™¨ç»‘å®šå·ï¼Œæ˜¯åœ¨å¯åŠ¨å®¹å™¨StartContainerçš„æ—¶å€™ï¼ŒæŠŠ Pod çš„å·ä¿¡æ¯ bind ç»™å®¹å™¨çš„&lt;/li&gt;
&lt;/ul&gt;
">Kuberneteså­¦ä¹ ç¬”è®° - Volume Manager</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://kzltime.cn/post/about/"" data-c="
          &lt;p&gt;âœï¸è¿™ä»…ä»…å°±æ˜¯ä¸€ä¸ªå­¦ä¹ ç¬”è®°&lt;/p&gt;
&lt;p&gt;ğŸƒâ€â™€ğŸƒâ€â™€ğŸƒâ€â™€ğŸƒâ€â™€ğŸƒâ€â™€&lt;/p&gt;
">å…³äº</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + 'ç§’ä¹‹å‰';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + 'åˆ†é’Ÿä¹‹å‰';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + 'å°æ—¶ä¹‹å‰';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + 'å¤©ä¹‹å‰';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //æ‹¿æ¥ä¸»ä¹‰(çœŸé¦™)^_^ï¼ŒClipboard å®ç°æ‘˜è‡ªæ˜é‡‘ https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // åˆ¤æ–­æ˜¯ä¸æ˜¯iosç«¯
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //åˆ›å»ºæ–‡æœ¬å…ƒç´ 
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //é€‰æ‹©å†…å®¹
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //å¤åˆ¶åˆ°å‰ªè´´æ¿
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("å¤åˆ¶é”™è¯¯ï¼è¯·æ‰‹åŠ¨å¤åˆ¶ï¼")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === 'å¤åˆ¶æˆåŠŸ') {
        return;
      }
      e.srcElement.textContent = 'å¤åˆ¶æˆåŠŸ';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === 'å¤åˆ¶æˆåŠŸ') {
            elem.textContent = 'å¤åˆ¶ä»£ç '
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = 'å¤åˆ¶ä»£ç ';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>